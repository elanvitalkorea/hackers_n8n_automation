
## 🎯 16차시 학습 목표

17차시의 최종 '유튜버-광고주 매칭 AI Agent' 프로젝트를 구현하기 전에, 16차시에서는 이 모든 자동화가 실행될 **인프라(Infra)** 와 **클라이언트(Client)** 를 완벽하게 준비합니다.

이번 차시에는 Next.js, S3, RAG DB, Flutter에서 배운 모든 지식을 총동원하여 **'AI Agent가 작업할 환경'** 을 모두 구축합니다.

  * **학습 목표:**
    1.  **(시나리오)** 16차시(준비)와 17차시(실행)의 전체 아키텍처를 이해합니다.
    2.  **(인프라/DB)** S3 버킷, Telegram 봇, Supabase RAG DB 등 모든 백엔드 인프라 셋업을 완료합니다.
    3.  **(광고주 클라이언트)** 광고주가 **성과 목표(CPM, CTR)와 예산**을 포함한 브리프를 제출할 **Next.js 웹 폼**을 구축하고 Vercel에 배포합니다.
    4.  **(관리자 클라이언트)** 관리자가 Agent를 모니터링하고 승인할 **Flutter 모바일 C\&C 앱**의 핵심 기능을 구현합니다.

-----

## 16-1. 통합 시나리오 소개

우리가 2개 차시에 걸쳐 완성할 실전 시나리오는 2개의 클라이언트(Web, Mobile)와 3개의 AI Agent가 협업하는 **'Full-Stack AI Agent 플랫폼'** 입니다.

![[Pasted image 20251120175447.png]]

1.  **(Client: 광고주) Next.js 웹 폼**
      * 광고주가 **Next.js 웹 폼**에 캠페인 내용(**예산, 목표 성과(CPM/CTR)** 포함)을 입력 후 제출합니다.
      * Next.js API Route가 이 폼 데이터를 **JSON 파일**로 변환하여 S3 `new/` 폴더에 업로드합니다.
2.  **(n8n - Agent 1) 브리프 분석 및 알림**
      * n8n이 1분 **폴링(Polling)** 으로 `new/` 폴더를 감지합니다.
      * AI가 브리프를 분석/요약하여 **정량적 목표(예산, CPM 등)** 를 JSON으로 추출, Supabase `campaigns` 테이블에 `status='pending_approval'`로 저장합니다.
      * **알림 (Hybrid):**
          * `Telegram`: 관리자에게 "🔔 새 캠페인 접수" 알림 전송.
          * `Flutter App`: Supabase 실시간 연동으로 '승인 대기' 항목이 앱 대시보드에 자동 표시됩니다.
3.  **(Client: 관리자) Flutter 대시보드 앱 (HITL)**
      * 관리자가 **Flutter 앱**에서 '승인 대기' 항목을 탭하여 AI가 분석/요약한 **광고주의 목표 스펙**을 검토합니다.
      * 앱 내의 [✅ 1차 승인] 버튼을 누릅니다.
      * Flutter 앱이 n8n의 Agent 2 웹훅을 `http.post`로 직접 호출합니다.
4.  **(n8n - Agent 2) (강화됨) 하이브리드 매칭 및 제안**
      * n8n(Agent 2)이 Flutter 앱의 호출을 받습니다.
      * **(로직 1: 필터링)** Supabase `youtubers` 테이블에서 광고주의 **예산, 목표 CPM, 목표 CTR, 인구통계**를 만족하는 유튜버 후보군을 **SQL로 필터링**합니다.
      * **(로직 2: RAG)** 필터링된 후보군 내에서만, 광고주의 **캠페인 의도(Summary)** 와 가장 **의미가 유사한** 유튜버를 **벡터 검색(RAG)** 으로 찾아냅니다.
      * AI가 이 하이브리드 매칭 결과를 바탕으로 제안서를 생성합니다.
      * `campaigns` 테이블에 `status='pending_proposal_approval'`로 저장합니다.
5.  **(Client: 관리자) Flutter 대시보드 앱 (HITL)**
      * 관리자가 Flutter 앱에서 AI가 작성한 제안서(성과 지표 포함)를 검토하고 [계약 진행] 버튼을 누릅니다.
      * Flutter 앱이 n8n의 Agent 3 웹훅을 호출합니다.
6.  **(n8n - Agent 3 & 마무리 워크플로우) PDF 계약 및 완료**
      * n8n(Agent 3)이 AI로 계약서(Markdown)를 생성 (유튜버별 단가 명시), DB에 저장 후, 마무리 워크플로우를 트리거합니다.
      * n8n(마무리 워크플로우)가 **PDF 생성 백엔드**를 호출하여 PDF를 S3에 저장하고, `status='completed'`로 변경합니다.
      * **최종 알림:** Telegram으로 "✅ 작업 완료" 메시지와 함께 **PDF 보안 링크**를 전송합니다.
      * Flutter 앱 대시보드에도 해당 항목이 '완료' 상태로 실시간 업데이트됩니다.


![[Pasted image 20251120180105.png]]

-----

## 16-2. 가상 유튜버 프로필 DB 구축

### 1\. 인프라 셋업

  * **AWS S3 셋업**
      * 버킷 생성: `[고유이름]-hackers-campaigns` (서울 리전, 퍼블릭 액세스 차단)
      * IAM 사용자 생성: `AmazonS3FullAccess` 권한 부여 (`액세스 키 ID`, `비밀 액세스 키` 확보)
      * **폴더 생성 (2개):**
          * `campaign-briefs/new/` (웹 폼이 업로드할 위치)
          * `campaign-briefs/processed/` (Agent 1이 분석 완료 후 이동시킬 폴더)
  * **Telegram 봇 셋업**
      * BotFather로 봇 생성 후 **HTTP API 토큰** 확보.
      * n8n 'Credentials'에 `Telegram` 토큰 등록.
      * `chat.id` 확인 (관리자 알림 수신용)

### 2\. Supabase DB 스키마

  * **(테이블 1) `youtubers` (정형 데이터/메타데이터) (수정됨)**

      * **(중요)** 광고 단가, 퍼포먼스(CPM, CTR), 핵심 인구통계 정보를 저장하여 Agent 2의 '정량 필터링'에 사용됩니다.

    <!-- end list -->

    ```sql
    CREATE TABLE youtubers (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        channel_name TEXT NOT NULL,
        subscriber_count INT NOT NULL DEFAULT 0,

        -- (신규) 광고 단가 및 퍼포먼스
        cost_per_video_usd INT DEFAULT 1000, -- 건당 광고 단가 (USD 기준)
        avg_cpm INT DEFAULT 0,                -- 평균 CPM (1000회 노출당 비용)
        avg_ctr_percent NUMERIC(4, 2) DEFAULT 0.00, -- 평균 클릭률 (%)

        -- (신규) 핵심 인구통계 (필터링용)
        main_demographics TEXT, -- 예: "MALE_20-30", "FEMALE_30-40"

        category TEXT,
        avg_views INT DEFAULT 0,
        keywords TEXT[],
        channel_link TEXT UNIQUE,
        tone_and_manner TEXT DEFAULT 'informative',
        created_at TIMESTAMPTZ DEFAULT now()
    );
    ALTER TABLE youtubers ENABLE ROW LEVEL SECURITY;
    CREATE POLICY "Allow public read access" ON youtubers
    FOR SELECT USING (true);
    ```

  * **(테이블 2) `documents` (의미/벡터 데이터) - (수정됨)**

      * (미리 `CREATE EXTENSION IF NOT EXISTS vector;` 실행 필요)
      * RAG가 유튜버의 소개글(톤앤매너, 성격)을 '의미 기반'으로 검색할 벡터 테이블입니다.

    <!-- end list -->

    ```sql
    CREATE TABLE documents (
        id bigserial PRIMARY KEY,
        content TEXT NOT NULL,          -- 원본 텍스트 (유튜버 소개글)
        embedding VECTOR(1536),         -- 'content'의 임베딩

        -- (중요) 원본 'youtubers' 테이블과 연결하는 정보 (14차시 스타일)
        metadata JSONB
    );
    ALTER TABLE documents ENABLE ROW LEVEL SECURITY;
    CREATE POLICY "Allow public read access" ON documents
    FOR SELECT USING (true);
    ```

  * **(테이블 3) `campaigns` (워크플로우 상태 저장)**

      * AI Agent의 작업 상태(`status`)와 **16-4 Flutter 모바일 앱**이 실시간 연동할 핵심 테이블입니다.


    ```sql
    CREATE TABLE campaigns (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        s3_key TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        ai_analysis JSONB,
        matched_youtubers JSONB,
        generated_proposal TEXT,
        generated_contract TEXT,
        final_contract_s3_key TEXT,
        created_at timestamptz DEFAULT now()
    );
    ALTER TABLE campaigns ENABLE ROW LEVEL SECURITY;
    CREATE POLICY "Allow all operations for service_role" ON campaigns
    FOR ALL USING (true) WITH CHECK (true);
    ```

* **(테이블 4) 하이브리드 검색 RPC 함수 (match\_documents\_by\_ids)**

  * **(중요)** 17차시 Agent 2는 **(1) SQL로 필터링된 후보군** 내에서 **(2) RAG 검색**을 수행해야 합니다.
  * 하지만 n8n의 기본 `Supabase Vector Store` 노드는 이러한 **메타데이터 필터링(`WHERE metadata->>'channel_id' = ANY(...)`)** 을 지원하지 않습니다.
  * 따라서, 이 기능을 수행하는 Supabase PostgreSQL 함수(RPC)를 DB에 미리 생성해 두어야 합니다.


```sql
-- 16차시 DB 셋업 시 반드시 실행해야 함
CREATE FUNCTION match_documents_by_ids(
  query_embedding vector(1536),
  match_count int,
  filter_ids uuid[] -- channel_id가 UUID 타입이므로 text[] 대신 uuid[] 사용 권장
)
returns table (
  id bigint,
  content text,
  metadata jsonb,
  similarity float
)
language sql stable
as $$
  select
    documents.id,
    documents.content,
    documents.metadata,
    1 - (documents.embedding <=> query_embedding) as similarity
  from documents
  -- (핵심) metadata의 channel_id가 filter_ids 배열에 포함된 것만 검색
  where (documents.metadata->>'channel_id')::uuid = ANY(filter_ids)
  order by documents.embedding <=> query_embedding
  limit match_count;
$$;
```

  * **(중요) Realtime 발행 설정**:

      * Flutter 앱이 `campaigns` 테이블의 변경사항을 실시간으로 받으려면, 테이블을 Supabase Realtime 발행에 추가해야 합니다.
      * Supabase SQL 편집기에서 아래 명령을 실행합니다.
        ```sql
        ALTER PUBLICATION supabase_realtime ADD TABLE campaigns;
        ```

### 3\. RAG 데이터 셋업 (Node.js 스크립트 방식)

#### 1\. 유튜버 프로필(정형) 삽입

  * `youtubers` 테이블에 **광고 단가, CPM, CTR, 인구통계**가 포함된 10명의 가상 유튜버 데이터를 `INSERT` 합니다.

    ```sql
    INSERT INTO youtubers
        (channel_name, subscriber_count, category, avg_views, keywords, channel_link, tone_and_manner, cost_per_video_usd, avg_cpm, avg_ctr_percent, main_demographics)
    VALUES
        ('Elanvital AI', 150000, 'IT', 50000, ARRAY['AI', 'n8n', '업무자동화'], 'https://youtube.com/@elanvitalai', 'professional', 5000, 15000, 3.50, 'MALE_20-30'),
        ('테크긱(TechGeek)', 85000, 'IT', 25000, ARRAY['신제품', '가젯', '리뷰'], 'https://youtube.com/techgeek', 'humorous', 3000, 18000, 2.80, 'MALE_20-30'),
        ('뷰티인사이드', 320000, '뷰티', 120000, ARRAY['메이크업', '스킨케어', '패션'], 'https://youtube.com/beautyinside', 'calm', 8000, 25000, 4.20, 'FEMALE_20-30'),
        ('게임마스터', 1100000, '게임', 350000, ARRAY['신작', '공략', '스트리밍'], 'https://youtube.com/gamemaster', 'humorous', 20000, 30000, 2.50, 'MALE_10-20'),
        ('머니트렌드', 450000, '경제', 180000, ARRAY['주식', '부동산', '재테크'], 'https://youtube.com/moneytrend', 'informative', 12000, 28000, 3.00, 'MALE_30-50'),
        ('미슐랭키친', 750000, '요리', 220000, ARRAY['레시피', '베이킹', '한식'], 'https://youtube.com/michelinkitchen', 'calm', 15000, 22000, 3.80, 'FEMALE_30-40'),
        ('라이프해커', 210000, '라이프스타일', 80000, ARRAY['미니멀리즘', '정리정돈', 'Vlog'], 'https://youtube.com/lifehacker', 'informative', 4500, 16000, 3.10, 'FEMALE_20-40'),
        ('열공쌤', 55000, '교육', 15000, ARRAY['학습법', '코딩교육', '입시'], 'https://youtube.com/studyteacher', 'professional', 2000, 12000, 2.00, 'MALE_10-20'),
        ('닥터웰니스', 680000, '라이프스타일', 190000, ARRAY['건강', '운동', '의학상식'], 'https://youtube.com/drwellness', 'informative', 18000, 32000, 3.30, 'FEMALE_40-60'),
        ('여행자김', 420000, '라이프스타일', 130000, ARRAY['해외여행', 'Vlog', '맛집'], 'https://youtube.com/travelerkim', 'humorous', 9000, 20000, 4.50, 'FEMALE_20-30');
    ```

#### 2\. 유튜버 소개글(벡터) 삽입 (1회성 스크립트)

  * 10명의 유튜버 소개글을 AI로 임베딩하여 `documents` 테이블에 삽입하는 1회성 Node.js 스크립트(`insert_vectors.mjs`)를 실행합니다.

  * **2-1. 프로젝트 셋업**

      * 새 Node.js 폴더를 만들고 `npm init -y`, `npm install @supabase/supabase-js openai dotenv`를 실행합니다.

  * **2-2. `.env` 파일 생성**

      * **(중요)** RLS를 우회하여 DB에 쓰기 위해 Supabase `service_role` 키를 사용합니다.

    <!-- end list -->

    ```.env
    OPENAI_API_KEY="sk-..."
    SUPABASE_URL="https://[your-project-id].supabase.co"
    SUPABASE_SERVICE_KEY="[your-service-role-key]"
    ```

  * **2-3. `insert_vectors.mjs` 스크립트 작성**

    ```javascript
    // insert_vectors.mjs
    import { createClient } from '@supabase/supabase-js';
    import OpenAI from 'openai';
    import 'dotenv/config'; // .env 파일 로드

    // 1. 클라이언트 초기화
    const supabaseAdmin = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_KEY
    );
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

    // 2. 임베딩할 10명의 유튜버 소개 텍스트 (채널명으로 매칭)
    const channelDescriptions = [
        { name: 'Elanvital AI', content: "AI와 n8n을 활용한 실무 업무 자동화(RPA) 전문가. RAG, LLM 등 최신 AI 기술을 비개발자도 이해하기 쉽게 설명하며, 실제 기업 컨설팅 사례를 바탕으로 한 전문적이고 깊이 있는 튜토리얼을 제공합니다. 개발자 및 기획자에게 적합합니다." },
        { name: '테크긱(TechGeek)', content: "최신 IT 기기, 스마트폰, 노트북, 혁신적인 가젯을 유쾌하고 재치있게 리뷰합니다. 복잡한 기술 용어 대신 실사용자 관점의 장단점을 솔직하게 비교하며, 20-30대 얼리어답터 남성 시청자들에게 인기가 높습니다. 밈(Meme)을 활용한 유머러스한 편집이 특징입니다." },
        { name: '뷰티인사이드', content: "30대 직장인 여성을 위한 고감도 뷰티 채널. 스킨케어 루틴, 퍼스널 컬러 진단, 로드샵 꿀템부터 명품 화장품까지 폭넓게 다룹니다. 차분하고 안정적인 목소리로 제품의 질감과 성분을 꼼꼼히 분석하며, 패션 하울과 스타일링 팁도 함께 제공합니다." },
        { name: '게임마스터', content: "100만 구독자의 10대-20대 남성 팬덤을 보유한 종합 게임 채널. 신작 게임 리뷰, 고난이도 공략, e스포츠 하이라이트 분석 전문. 하이텐션의 유머러스한 입담과 스트리밍 방송으로 시청자와의 소통이 활발하며, 특히 FPS와 RPG 장르에 강점이 있습니다." },
        { name: '머니트렌드', content: "주식, 부동산, 재테크 등 복잡한 경제 뉴스를 명쾌하게 분석하는 채널. 30-50대 남녀 직장인 및 자영업자 구독자 비중이 높음. 시장의 흐름을 읽는 인사이트와 실질적인 투자 전략을 제공하며, 신뢰감 가는 정보 전달(informative)에 집중합니다." },
        { name: '미슐랭키친', content: "전문 파티시에가 알려주는 고품격 홈베이킹과 파티 요리 전문. 감성적인 영상미와 차분한 ASMR 스타일의 내레이션이 특징. 한식, 양식, 디저트 등 장르를 가리지 않으며, 자취생을 위한 간단한 레시피부터 특별한 날을 위한 파티 요리까지 다룹니다." },
        { name: '라이프해커', content: "미니멀리즘, 정리정돈, 생산성 향상 습관을 다루는 라이프스타일 채널. 단순한 VLOG를 넘어, 삶을 효율적으로 관리하는 노하우(self-improvement)와 인테리어 팁을 공유합니다. 20-40대 여성 구독자 비중이 높으며, 차분하고 정돈된 톤앤매너를 유지합니다." },
        { name: '열공쌤', content: "청소년과 대학생, 취준생을 위한 학습법 전문 채널. 효율적인 공부법, 코딩 교육의 필요성, 입시 전략, 영어 및 자격증 준비 노하우를 다룹니다. 전문적이고 논리적인 설명으로 학생과 학부모 모두에게 신뢰를 얻고 있습니다." },
        { name: '닥터웰니스', content: "현직 가정의학과 전문의가 운영하는 건강 정보 채널. 다이어트, 운동법, 최신 의학 상식, 멘탈 케어 등 웰니스 전반을 다룹니다. 과학적 근거(informative)를 바탕으로 루머를 바로잡고, 40-60대 중장년층에게 특히 인기가 높습니다." },
        { name: '여행자김', content: "전 세계를 누비는 부부 여행 크리에이터. 유쾌하고(humorous) 에너지 넘치는 VLOG, 현지 맛집 탐방, 숨겨진 여행 팁을 공유합니다. 가성비 여행부터 럭셔리 여행까지 폭넓게 다루며, 20-30대 예비 여행자들에게 강력한 동기부여를 제공합니다." }
    ];

    async function processEmbeddings() {
      console.log('1. `youtubers` 테이블에서 ID를 조회합니다...');
      const { data: youtubers, error: fetchError } = await supabaseAdmin
        .from('youtubers')
        .select('id, channel_name');

      if (fetchError) { console.error('유튜버 조회 실패:', fetchError); return; }

      // { 'Elanvital AI': 'uuid-...' } 형태의 맵 생성
      const youtuberMap = new Map(youtubers.map(y => [y.channel_name, y.id]));

      // 2. OpenAI 임베딩 요청 (10개 텍스트 일괄 처리)
      console.log('2. OpenAI 임베딩 API를 호출합니다...');
      const textsToEmbed = channelDescriptions.map(d => d.content);
      const embeddingResponse = await openai.embeddings.create({
        model: "text-embedding-ada-002",
        input: textsToEmbed,
      });

      // 3. Supabase `documents` 테이블에 삽입할 데이터 준비
      const documentsToInsert = channelDescriptions.map((desc, index) => {
        const channelId = youtuberMap.get(desc.name);
        if (!channelId) { console.warn(`${desc.name}의 ID를 찾을 수 없습니다.`); return null; }

        return {
          content: desc.content,
          embedding: embeddingResponse.data[index].embedding, // 'embedding' 컬럼
          metadata: {                                        // 'metadata' JSONB 컬럼
            "channel_id": channelId,
            "channel_name": desc.name
          }
        };
      }).filter(Boolean); // null이 아닌 항목만 필터링

      if (documentsToInsert.length === 0) { console.error('삽입할 문서가 없습니다.'); return; }

      // 4. Supabase `documents` 테이블에 일괄 삽입
      console.log(`3. ${documentsToInsert.length}개의 벡터 데이터를 \`documents\` 테이블에 삽입합니다...`);
      const { error: insertError } = await supabaseAdmin
        .from('documents')
        .insert(documentsToInsert);

      if (insertError) {
        console.error('벡터 삽입 실패:', insertError);
      } else {
        console.log('✅ 성공! 모든 유튜버 프로필이 벡터로 변환되어 저장되었습니다.');
      }
    }

    processEmbeddings();
    ```

  * **(중요)** 이 스크립트는 RLS를 우회하기 위해 Supabase `service_role` 키를 사용해야 합니다.

  * 스크립트 실행 (`node insert_vectors.mjs`) 후 `documents` 테이블에 10개의 벡터가 생성되었는지 확인합니다.

#### 3\. 캠페인 테이블 합성 데이터 생성 (Flutter 앱 테스트용)

  * Flutter 앱의 실시간 업데이트 및 다양한 상태 UI 테스트를 위해 `campaigns` 테이블에 합성 데이터를 생성하는 스크립트(`scripts/generate_campaigns.mjs`)를 실행합니다.

  * **3-1. 스크립트 사용법**

    ```bash
    # 기본 5개 생성
    node scripts/generate_campaigns.mjs

    # 10개 생성
    node scripts/generate_campaigns.mjs --count=10

    # 기존 데이터 삭제 후 생성
    node scripts/generate_campaigns.mjs --wipe
    ```

  * **3-2. 생성되는 데이터 구조**

    * **다양한 상태 지원**: `pending`, `pending_approval`, `pending_proposal_approval`, `completed`
    * **`matched_youtubers`**: Agent 2가 생성한 단일 JSON 객체 (배열 아님)
      * `original_cost_per_video_usd`: 유튜버의 원본 단가
      * `cost_per_video_usd`: Agent 2가 총 예산(`budgetUSD`)으로 덮어쓴 값 (집행 예산)
      * `similarity`: RAG 검색의 유사도 점수
      * `reason`: 정성적/정량적 매칭 근거
    * **`generated_proposal`**: 17차시 Agent 2의 "종합 보고서 양식"에 맞춘 제안서 마크다운
      * 복수 후보인 경우 "후보 비교 분석" 및 "최종 추천 전략 및 사유" 섹션 포함
      * 단일 후보인 경우 후보 상세 분석만 포함

  * **3-3. 환경 변수**

    * `.env.local` 파일에 다음 변수가 필요합니다:
      ```bash
      SUPABASE_URL="https://[your-project-id].supabase.co"
      SUPABASE_SERVICE_KEY="[your-service-role-key]"
      ```

  * **3-4. 상세 사용법**

    * 자세한 내용은 `docs/TEST_GUIDE.md`의 "6. `generate_campaigns.mjs` - 캠페인 테이블 합성 데이터 생성" 섹션을 참조하세요.

-----

## 16-3. 광고 기획서 템플릿 제작

16-2에서 DB와 인프라 구축을 완료했습니다. `16-3`에서는 이 시스템과 상호작용할 두 개의 클라이언트, 즉 광고주가 기획서를 **'제출'** 하는 **Next.js 웹 앱**과 관리자가 제출된 기획서를 **'통제'** 하는 **Flutter 모바일 앱**을 모두 구축합니다.

### 1\. 광고 기획서 템플릿 (합성 데이터 예시)

먼저, 17차시의 AI Agent가 분석하고 처리할 광고 브리프 **JSON 파일**의 표준 형식 예시를 확인합니다. Next.js 웹 폼은 바로 이 형식의 데이터를 생성하여 S3에 업로드하게 됩니다.

> **`brief_form_01_ai_laptop_review.json`**
>
> ```json
> {
>   "companyName": "기가코퍼레이션",
>   "advertiserName": "박민수",
>   "email": "marketing@giga.co.kr",
>   "productName": "AI 가속 노트북 'GigaBook X1'",
>   "budgetUSD": 12000,
>   "targetDemographics": "MALE_20-30",
>   "targetCPM": 20000,
>   "targetCTR": 3.0,
>   "details": "AI 업무자동화와 개발자 워크플로우를 중심으로 성능을 보여주는 인플루언서 리뷰를 원합니다. 실사용 벤치마크와 n8n/RAG 활용 예시가 포함되면 좋습니다."
> }
> ```
>
> **`brief_form_02_k_beauty_skin.json`**
>
> ```json
> {
>   "companyName": "루미에르코스메틱",
>   "advertiserName": "최서현",
>   "email": "pr@lumiere.com",
>   "productName": "하이알루론 산뜻세럼",
>   "budgetUSD": 18000,
>   "targetDemographics": "FEMALE_20-30",
>   "targetCPM": 25000,
>   "targetCTR": 4.0,
>   "details": "수부지 피부를 위한 수분 레이어링 루틴에 자연스럽게 녹여낸 협찬 영상을 선호합니다. 피부결 개선과 텍스처 표현이 핵심입니다."
> }
> ```

### 2\. 광고주 클라이언트 구축 (Next.js 웹앱)

16-2에서 준비한 S3 버킷에 광고주가 브리프를 업로드할 '얼굴'이 필요합니다. 11차시에서 배운 Next.js 지식을 총동원하여 브리프 제출 웹 폼을 구축하고 Vercel에 배포합니다.

#### 1\. 프로젝트 기획 (PRD 요약)

  * **목표**: 광고주가 캠페인 정보(**예산, 목표 CPM/CTR, 타겟 인구통계** 포함)를 제출하면, **JSON 파일**로 변환하여 AWS S3 (`campaign-briefs/new/`)에 업로드합니다.
  * **기술 스택**: Next.js 15 (App Router), Tailwind CSS v4, Next.js API Routes, **AWS SDK (`@aws-sdk/client-s3`)**, Vercel, **`.env.local` 환경 변수 관리**
  * **UI/UX 컨셉**: **Dark Glassmorphism** (11차시 PRD 컨셉 재활용). 어두운 배경에 반투명한 폼 카드를 사용하여 전문적이고 모던한 UI를 구현합니다.

#### 2\. 페이지 명세 (11차시 복습)

  * **`/` (메인: 브리프 제출 페이지)**
      * **렌더링**: **SSG (Static Site Generation)** (폼 자체는 정적이므로 로딩 속도 최적화)
      * **UI**: Dark Glassmorphic 디자인의 폼 카드 (`"use client"` 필요).
      * **입력 필드** (17차시 AI 분석 기준):
          * 광고주명 (text, 필수)
          * 회사 이메일 (email, 필수, 연락용)
          * 회사명 (text, 필수)
          * 제품/서비스명 (text, 필수)
          * **(수정됨)** 캠페인 총 예산 (number, 필수, **USD** 달러 기준)
          * **(신규)** 목표 CPM (number, 선택, 예: 20000원 이하)
          * **(신규)** 목표 CTR (number, 선택, 예: 3.5% 이상)
          * **(신규)** 핵심 타겟 인구통계 (Select, 필수, ENUM 값 사용)
              * **ENUM 값 목록** (DB `youtubers.main_demographics` 컬럼과 정확히 일치해야 함):
                  * `MALE_10-20` (10-20대 남성)
                  * `MALE_20-30` (20-30대 남성)
                  * `MALE_30-50` (30-50대 남성)
                  * `FEMALE_20-30` (20-30대 여성)
                  * `FEMALE_20-40` (20-40대 여성)
                  * `FEMALE_30-40` (30-40대 여성)
                  * `FEMALE_40-60` (40-60대 여성)
              * **중요**: selectbox의 `value` 속성은 ENUM 값으로, 표시 텍스트는 한글로 설정됨. 이 값은 17차시 Agent 2의 SQL 필터링에서 `main_demographics eq {{ ENUM값 }}` 형식으로 사용됨.
          * 캠페인 상세 내용 (textarea, 필수, 캠페인 의도)
      * **제출 로직**:
          * '브리프 제출하기' 버튼 클릭 시 클라이언트 사이드 유효성 검사 수행.
          * 성공 시 `POST /api/brief` API 호출 (호출 중 로딩 스피너 표시).
          * API 호출 성공 시 `/success` 페이지로 리다이렉트 (`router.push('/success')`).
  * **`/success` (제출 완료 페이지)**
      * **렌더링**: **SSG (Static Site Generation)** (정적 감사 메시지).
      * **핵심 기능**:
        1.  "✅ 브리프 제출이 완료되었습니다." 메시지 표시.
        2.  "담당자가 검토 후 영업일 기준 1-2일 내에 기입하신 이메일로 연락드릴 예정입니다." 안내 문구.
        3.  '새 브리프 작성하기' 버튼 (`<Link href="/">`)

#### 3\. API 명세: `POST /api/brief` (핵심 로직)

  * 11차시에서 배운 `src/app/api/brief/route.ts` 파일을 생성합니다.
  * **역할**: 폼 데이터를 S3에 `.json` 파일로 업로드하는 서버리스 백엔드.
  * **주요 로직**:
    1.  `await request.json()`: 클라이언트 폼에서 보낸 JSON 데이터를 수신합니다.
    2.  **[Logic] 데이터 변환**: 수신한 JSON을 17차시 AI Agent가 분석할 **JSON 형식**으로 변환합니다. (문자열 필드는 그대로, 숫자 필드(`budgetUSD`, `targetCPM`, `targetCTR`)는 숫자 타입으로 변환) (아래 예시 참조)
    3.  **[Logic] 파일명 생성**: 고유 파일명 생성 (예: `brief-form-${Date.now()}-${uuid()}.json`).
    4.  **[AWS] S3 클라이언트 초기화**: `new S3Client(...)`
          * **(보안)** **로컬 개발 시에는 `.env.local` 파일에, 프로덕션 배포 시에는 Vercel 환경 변수**에 `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_REGION` 키를 등록하여 `process.env`로 안전하게 호출합니다. (11차시 API Route 장점 복습)
    5.  **[AWS] S3 업로드**: `new PutObjectCommand(...)`
          * **Bucket**: `[고유이름]-hackers-campaigns`
          * **Key**: `campaign-briefs/new/[생성된 고유 파일명].json`
          * **Body**: `JSON.stringify(jsonDataToSave, null, 2)` (JSON 문자열)
          * **ContentType**: `application/json`
    6.  `NextResponse.json({ success: true }, { status: 201 })`: 성공 응답을 반환합니다.

> **JSON 형식 예시 (S3에 저장될 `.json` 파일 내용)**:
>
> ```json
> {
>   "companyName": "기가코퍼레이션",
>   "advertiserName": "박민수",
>   "email": "marketing@giga.co.kr",
>   "productName": "AI 가속 노트북 'GigaBook X1'",
>   "budgetUSD": 12000,
>   "targetDemographics": "MALE_20-30",
>   "targetCPM": 20000,
>   "targetCTR": 3.0,
>   "details": "AI 업무자동화와 개발자 워크플로우를 중심으로 성능을 보여주는 인플루언서 리뷰를 원합니다. 실사용 벤치마크와 n8n/RAG 활용 예시가 포함되면 좋습니다."
> }
> ```








#### 4\. Vercel 배포 및 S3 연동 테스트 (12차시 예습)

1.  **(신규)** 로컬 개발을 위해 프로젝트 루트에 `.env.local` 파일을 생성하고 16-2에서 발급받은 AWS 키를 등록합니다. (이 파일은 `.gitignore`에 반드시 추가합니다.)
    ```.env.local
    AWS_ACCESS_KEY_ID="AKIA..."
    AWS_SECRET_ACCESS_KEY="[YourSecretKey]"
    AWS_REGION="ap-northeast-2"
    ```
2.  코드를 GitHub에 푸시하고 Vercel에 프로젝트를 연동합니다.
3.  Vercel 프로젝트 **'Environment Variables'** 에 `.env.local`과 **동일한 키**( `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_REGION` 등)를 프로덕션용으로 등록합니다.
4.  배포된 Vercel 웹 앱 주소에 접속하여 테스트 브리프(예: 기가코퍼레이션 AI 노트북)를 제출합니다.
5.  **AWS S3 콘솔** `campaign-briefs/new/` 폴더에 `brief-form-....json` 파일이 정상적으로 업로드되었는지 최종 확인합니다.

### 3\. 관리자 클라이언트 구축 (Flutter 모바일 앱)

17차시의 AI Agent를 실시간으로 모니터링하고(C\&C: Command and Control), 인간의 승인(HITL)을 처리할 관리자용 모바일 앱을 15차시 지식을 복습하여 구축합니다.

#### 1\. 프로젝트 기획 (PRD 요약)

  * **🎯 목표**: AI Agent가 처리하는 `campaigns` 테이블의 상태를 실시간으로 모니터링하고, 관리자가 '승인' 버튼을 눌러(HITL) n8n Agent의 다음 단계를 트리거하는 C\&C 모바일 앱을 구축합니다.
  * **🤖 기술 스택**: Flutter, `supabase_flutter` (실시간 스트림 구독), `http` (n8n 웹훅 호출용), **`flutter_markdown` (제안서 렌더링용)**, **`flutter_dotenv` (API 키 및 환경 변수 관리용)**.
  * **🎨 UI/UX 컨셉**: **"실시간 C\&C 대시보드 (Real-time C\&C Dashboard)"**
      * 'Dark Glassmorphism'이 외부 광고주용의 화려한 UI라면, 이 앱은 **내부 관리자용**이므로 **기능성, 즉각성, 명확성**에 초점을 맞춥니다.
      * **Dark Mode (어두운 테마)** 를 기본으로 하여 "Mission Control" (관제 센터)의 느낌을 주며, 관리자의 눈의 피로를 줄입니다.
      * 모든 데이터는 사용자가 새로고침할 필요 없이 **Supabase Realtime**을 통해 즉시 화면에 반영되어야 합니다.

-----

#### 2\. 화면 명세

##### 2-1. `home_screen.dart` (메인: 실시간 대시보드)

  * **역할**: `campaigns` 테이블의 모든 항목을 실시간으로 구독하고, 상태별로 분류하여 섹션으로 표시합니다.
  * **데이터 소스**: `supabase.from('campaigns').stream(primaryKey: ['id'])`
  * **UI 컴포넌트**:
      * **AppBar**: "AI Agent C\&C 대시보드" 타이틀.
      * **Body**: `StreamBuilder`를 사용하여 Supabase 스트림을 구독.
          * **로딩 중일 시**: `Center(child: CircularProgressIndicator())`
          * **에러 발생 시**: 에러 메시지를 표시합니다.
          * **데이터가 없을 시 (빈 리스트)**:
              * 아이콘 (`Icons.inbox_outlined`)과 함께 "대기 중인 캠페인이 없습니다." 메시지 표시
              * 추가 안내: "S3에 파일이 있어도 Agent 1이 분석하기 전까지는 대시보드에 표시되지 않습니다." (작은 글씨)
      * **상태별 섹션 (Card 기반)**:
          * 데이터를 상태별로 분류하여 3개의 섹션으로 표시합니다.
          * **1차 섹션: "1차 승인 대기"**
              * 상태: `pending_approval`
              * 아이콘: `Icons.warning_amber_rounded` (노란색)
              * 헤더: "1차 승인 대기 (AI 분석 검토 필요)" - 제목 옆에 덜 강조된 텍스트로 설명 표시
              * 헤더에 항목 개수 배지 표시
              * 해당 상태의 캠페인만 리스트로 표시
          * **2차 섹션: "2차 승인 대기"**
              * 상태: `pending_proposal_approval`
              * 아이콘: `Icons.edit_note_rounded` (주황색)
              * 헤더: "2차 승인 대기 (제안서 검토 필요)" - 제목 옆에 덜 강조된 텍스트로 설명 표시
              * 헤더에 항목 개수 배지 표시
              * 해당 상태의 캠페인만 리스트로 표시
          * **3차 섹션: "완료"**
              * 상태: `completed`
              * 아이콘: `Icons.check_circle_outline_rounded` (녹색)
              * 헤더: "완료" (설명 없음)
              * 헤더에 항목 개수 배지 표시
              * 해당 상태의 캠페인만 리스트로 표시
          * **섹션 헤더**: 각 섹션은 Card로 감싸져 있으며, 헤더에 아이콘, 제목(및 설명), 항목 개수 배지가 표시됩니다.
          * **섹션 내 항목 (ListTile)**:
              * `leading`: 상태에 따른 아이콘
              * `title`: 캠페인 제목 (`ai_analysis`에서 `companyName`과 `productName`을 조합하여 "회사명 - 제품명" 형식으로 표시. `ai_analysis`가 없으면 `s3_key`에서 파일명 추출)
              * `subtitle`: 파일명 (`s3_key`에서 파일명만 추출)
              * `trailing`: `Icons.chevron_right`
              * **Null 안전성**: 모든 필드에 대해 null 체크 및 기본값 처리 필수
          * **빈 섹션 처리**: 항목이 없는 섹션은 표시하지 않습니다.
  * **핵심 로직**:
      * `StreamBuilder`로 받은 데이터를 상태별로 필터링합니다.
      * 각 섹션은 `_buildSection` 메서드로 생성되며, 빈 섹션은 표시하지 않습니다.
      * `ListTile`의 `onTap` 시, 해당 `campaign` 맵 데이터를 `DetailScreen`으로 전달하며 화면을 전환합니다 (`Navigator.push`).

##### 2-2. `detail_screen.dart` (상세: HITL 승인 화면)

  * **역할**: `HomeScreen`에서 전달받은 캠페인 상세 정보를 표시하고, 관리자의 '승인' 액션을 처리합니다.
  * **데이터 소스**: `HomeScreen`에서 생성자(Constructor)를 통해 전달받은 `Map<String, dynamic> campaignData`.
  * **UI 컴포넌트**:
      * **AppBar**: 상태에 따라 동적으로 타이틀이 변경됩니다.
          * `pending_approval`: "캠페인 상세 승인"
          * `pending_proposal_approval`: "제안서 검토"
          * `completed`: "캠페인 완료 결과"
      * **Body**: `Padding`과 `SingleChildScrollView` (데이터가 길어질 수 있으므로)
          * **회사명/제품명 헤더**: `ai_analysis`에서 `companyName`과 `productName`을 추출하여 상단에 크게 표시합니다.
          * **상태별 메인 섹션 구성**:
              * **1차 승인 대기 (`pending_approval`)**: "제출 내용" 섹션 (AI 분석 결과 포함)
              * **2차 승인 대기 (`pending_proposal_approval`)**: "AI 제안서 내용" 섹션 (메인)
              * **완료 (`completed`)**: "캠페인 완료 결과" 섹션 (메인, 제안서 + 계약서)
          * **섹션 1-1: 제출 내용** (1차 승인 대기 상태일 때만 표시)
              * **섹션 헤더**: 아이콘(`Icons.description_outlined`)과 함께 "제출 내용" 제목 표시.
              * **레이아웃 순서** (위에서 아래로):
                  1. **기본 정보** (회사명, 광고주명, 이메일, 제품/서비스명)
                  2. **예산 및 성과 목표** (Chip으로 표시: `budgetUSD`, `targetCPM`, `targetCTR`, `targetDemographics`)
                  3. **캠페인 상세** (`summary` - AI 분석 결과 포함, `details`)
              * **AI 분석 결과**: `summary` 필드는 "AI 분석: 캠페인 핵심 의도" 레이블과 함께 청록색 박스로 강조 표시됩니다.
          * **섹션 1-2: AI 제안서 내용** (2차 승인 대기 또는 완료 상태일 때 표시)
              * **섹션 헤더**: 
                  * 2차 승인 대기: 아이콘(`Icons.description`)과 함께 "AI 제안서 내용" 제목 표시.
                  * 완료: 아이콘(`Icons.check_circle`, 녹색)과 함께 "캠페인 완료 결과" 제목 표시 (녹색 강조).
              * **레이아웃 순서** (위에서 아래로):
                  1. **최종 선정 유튜버 정보** (제일 상단)
                  2. **캠페인 상세** (`summary`, `details` - `ai_analysis`에서 가져옴)
                  3. **예산 및 성과 목표** (Chip으로 표시: `budgetUSD`, `targetCPM`, `targetCTR`, `targetDemographics`)
                  4. **제안서 마크다운** (가장 아래)
                  5. **계약서 내용** (완료 상태일 때만 표시)
              * **1. 최종 선정 유튜버 정보** (제일 상단에 표시):
                  * `campaignData['matched_youtubers']` **단일 JSON 객체**를 파싱하여 유튜버 정보를 카드 형식으로 표시합니다.
                  * **(중요)** `matched_youtubers`는 배열이 아닌 **단일 객체**입니다. Agent 2가 여러 후보를 분석한 후 최적의 후보 1명만 선택하여 저장합니다. 따라서 이 데이터는 **"최종 선정 유튜버"**를 의미합니다.
                  * 카드에는 다음 정보가 포함됩니다:
                      * 채널명 (`channel_name`) - 별 아이콘(⭐)과 함께 강조 표시
                      * 채널 설명 요약 (`content_summary`) - RAG 검색 결과에서 추출된 유튜버 소개글 요약
                      * **원본 단가와 집행예산 구분 표시**:
                          * 원본 단가 (`original_cost_per_video_usd`) - 회색 박스로 표시 (유튜버의 실제 단가)
                          * 집행예산 (`cost_per_video_usd` - Agent 2가 총 예산으로 덮어쓴 값) - 초록색 박스로 표시, 아이콘 포함
                      * 성과 지표 Chip: CPM (`avg_cpm`), CTR (`avg_ctr_percent`) - AI 유사도는 칩에서 제거하고 `reason` 필드에만 포함
                      * 선정 사유 (`reason`) - 파란색 박스로 강조 표시, AI가 생성한 정성적+정량적 매칭 근거 (유사도 점수 포함)
                  * **UX 목적**: 관리자가 제안서를 읽기 전에 최종 선정된 유튜버의 핵심 정보를 먼저 확인할 수 있도록 최상단에 배치합니다.
                  * **시각적 강조**: 제목에 별 아이콘(⭐)을 추가하고, 카드 내부의 채널명 옆에도 별 아이콘을 표시하여 "최종 선정"의 의미를 명확히 합니다.
                  * **Null 처리**: `matched_youtubers`가 `null`이거나 비어있으면 표시하지 않음.
              * **2. 캠페인 상세** (`ai_analysis`에서 가져옴):
                  * 캠페인 핵심 의도 (`summary`) - 청록색 박스로 강조 표시
                  * 캠페인 상세 내용 (`details`) - Key-Value 형식으로 표시
              * **3. 예산 및 성과 목표** (Chip으로 강조 표시):
                  * 총 예산 (`budgetUSD`), 목표 CPM (`targetCPM`), 목표 CTR (`targetCTR`), 타겟 인구통계 (`targetDemographics`)
              * **4. 제안서 마크다운**: `campaignData['generated_proposal']`을 `MarkdownBody` 위젯으로 렌더링합니다.
                  * (UX Tip) `flutter_markdown` 패키지의 **`MarkdownBody`** 위젯을 사용하여 렌더링합니다. (단순 `Text` 위젯이 아님).
                  * **(중요)** 제안서에는 Agent 2가 복수 후보를 분석한 경우 **"후보 비교 분석"** 섹션이 포함될 수 있으며, 이를 통해 AI의 의사결정 과정을 투명하게 확인할 수 있습니다.
                  * **Null 처리**: `generated_proposal`이 `null`이거나 비어있으면 표시하지 않음.
              * **5. 계약서 내용** (완료 상태일 때만 표시):
                  * `generated_contract` (Markdown 형식 계약서)를 `MarkdownBody` 위젯으로 렌더링합니다.
                  * `final_contract_s3_key` (PDF S3 키) 정보를 표시합니다.
          * **섹션 2: 원본 제출 내용** (2차 승인 대기 또는 완료 상태일 때만 참고용으로 표시)
              * `campaignData['ai_analysis']`를 **섹션별로 그룹화**하여 시각적으로 강조하여 표시합니다.
              * **섹션 헤더**: 아이콘(`Icons.archive_outlined`, 회색)과 함께 "원본 제출 내용" 제목 표시.
              * **참고 안내**: "참고용: 광고주가 최초 제출한 내용입니다" 안내 문구를 작은 회색 텍스트로 표시하여 덜 강조합니다.
              * **1) 기본 정보 섹션**:
                  * 회사명 (`companyName`) - 아이콘: `Icons.business`
                  * 광고주명 (`advertiserName`) - 아이콘: `Icons.person`
                  * 이메일 (`email`) - 아이콘: `Icons.email`
                  * 제품/서비스명 (`productName`) - 아이콘: `Icons.inventory_2`
                  * 각 필드는 아이콘과 함께 Key-Value 레이블 형식으로 표시 (레이블: 작은 회색 텍스트, 값: 큰 흰색 텍스트).
              * **2) 예산 및 성과 목표 섹션** (Chip으로 강조 표시):
                  * **총 예산** (`budgetUSD`) - 초록색 Chip, 아이콘: `Icons.attach_money`, "USD" 접미사
                  * **목표 CPM** (`targetCPM`) - 파란색 Chip, 아이콘: `Icons.trending_up`
                  * **목표 CTR** (`targetCTR`) - 주황색 Chip, 아이콘: `Icons.touch_app`
                  * **타겟 인구통계** (`targetDemographics`) - 보라색 Chip, 아이콘: `Icons.people`
                  * 각 Chip은 레이블(작은 텍스트)과 값(큰 굵은 텍스트)을 2줄로 표시하며, 색상으로 구분하여 한눈에 파악 가능하도록 합니다.
              * **3) 캠페인 상세 섹션**:
                  * **캠페인 핵심 의도** (`summary`) - 청록색 박스로 강조 표시, 아이콘: `Icons.auto_awesome`, 이탤릭체 텍스트
                  * **캠페인 상세 내용** (`details`) - 아이콘: `Icons.description`과 함께 Key-Value 형식으로 표시
              * **Null 처리**: `ai_analysis`가 `null`이면 "제출된 데이터가 아직 없습니다. Agent 1이 분석을 완료하면 여기에 표시됩니다." 메시지 표시.
              * **에러 처리**: JSON 파싱 실패 시 원본 데이터를 문자열로 표시 (try-catch 사용).
      * **ActionButton (`ElevatedButton`)**:
          * 화면 하단에 배치되며, **`status`에 따라 버튼의 텍스트와 기능이 완전히 변경**되어야 합니다.
  * **핵심 로직 (조건부 UI 및 액션)**:
      * `build` 메서드 내에서 `status`를 확인하여 버튼의 텍스트와 `onPressed` 콜백을 동적으로 결정합니다.
      * **상태 1: `status == 'pending_approval'`**
          * **버튼 텍스트**: "✅ 1차 승인 (AI 분석 검토 완료)"
          * **버튼 활성화**: `onPressed`에 `_triggerN8nAgent` 함수 연결.
          * **호출할 웹훅 (Target)**: **`dotenv.env['N8N_WEBHOOK_URL_APPROVE']!`** (환경 변수에서 로드)
      * **상태 2: `status == 'pending_proposal_approval'`**
          * **버튼 텍스트**: "✍️ 2차 승인 (제안서 검토 완료)"
          * **버튼 활성화**: `onPressed`에 `_triggerN8nAgent` 함수 연결.
          * **호출할 웹훅 (Target)**: **`dotenv.env['N8N_WEBHOOK_URL_CONTRACT']!`** (환경 변수에서 로드)
      * **그 외 상태 (예: `completed`, `pending` 등)**
          * **버튼 텍스트**: "🎉 작업 완료" 또는 "처리 중..."
          * **버튼 비활성화**: `onPressed: null` (클릭 불가)

-----

#### 3\. 환경 변수 (ENV) 관리 (신규)

  * **🎯 목표**: Supabase 키, n8n 웹훅 URL 등 민감한 정보를 소스 코드에서 분리하여 `.env` 파일로 관리합니다.
  * **📦 패키지**: `flutter_dotenv`
  * **⚙️ 설정**:
    1.  `pubspec.yaml`에 `flutter_dotenv`를 추가합니다.
    2.  프로젝트 루트(최상위)에 `.env` 파일을 생성합니다.
    3.  `.gitignore` 파일에 `.env`를 추가하여 깃 저장소에 커밋되지 않도록 합니다.
  * **📄 `.env` 파일 내용 (예시)**:
    '''ini
    SUPABASE_URL=https://[YOUR_PROJECT_ID].supabase.co
    SUPABASE_ANON_KEY=[YOUR_SUPABASE_ANON_KEY]
    N8N_WEBHOOK_URL_APPROVE=https://[YOUR_N8N_URL]/webhook/17-2-approve
    N8N_WEBHOOK_URL_CONTRACT=https://[YOUR_N8N_URL]/webhook/17-3-contract
    '''

-----

#### 4\. API 및 핵심 로직 명세

##### 4-1. `main.dart`: Supabase 초기화

  * **역할**: 앱 실행 시 `.env` 파일에서 환경 변수를 로드하고 Supabase 클라이언트를 전역으로 초기화합니다.
  * **로직**: `main` 함수 내에서
    1.  `WidgetsFlutterBinding.ensureInitialized();`를 호출하여 Flutter 바인딩을 초기화합니다.
    2.  `try-catch` 블록으로 에러 처리를 감쌉니다.
    3.  `await dotenv.load(fileName: ".env");`를 호출하여 환경 변수를 로드합니다.
    4.  환경 변수 검증:
          * `SUPABASE_URL`과 `SUPABASE_ANON_KEY`가 `null`이거나 비어있으면 예외를 발생시킵니다.
    5.  `await Supabase.initialize(...)`를 호출하여 Supabase 클라이언트를 초기화합니다.
    6.  **에러 처리**: 초기화 실패 시 사용자에게 명확한 에러 화면을 표시합니다.
          * 에러 아이콘과 메시지 표시
          * 확인 사항 체크리스트 제공 (.env 파일 위치, 환경 변수 설정, Supabase 프로젝트 활성화 여부)

##### 4-2. `detail_screen.dart`: n8n Agent 호출 함수

  * **역할**: n8n Agent의 웹훅을 HTTP POST로 호출합니다.
  * **함수 명세**: `Future<void> _triggerN8nAgent({required String webhookUrl, required String campaignId})`
  * **로직**:
    1.  `http` 패키지를 사용 (`import 'package:http/http.dart' as http;`).
    2.  `try...catch` 문으로 네트워크 오류를 감싸야 합니다.
    3.  `http.post` 호출:
          * `Uri.parse(webhookUrl)`
          * `headers`: `{'Content-Type': 'application/json'}`
          * `body`: `json.encode({'campaign_id': campaignId})` (17차시 n8n Agent가 작업을 식별할 ID 전송)
    4.  **(UX)** 호출 시작 시 로딩 인디케이터 표시, 완료 시 `Navigator.pop(context)`로 대시보드 복귀. (대시보드는 `StreamBuilder`이므로 자동으로 상태가 갱신됨)

-----

#### 5\. Supabase 연동 및 테스트 계획 (Definition of Done)

1.  **(수정)** 프로젝트 루트에 `.env` 파일을 생성하고 3번 섹션(`환경 변수 (ENV) 관리`)에 명시된 **`SUPABASE_URL`**, **`SUPABASE_ANON_KEY`** 및 **n8n 웹훅 URL**들을 입력합니다.
2.  **(중요) Supabase RLS 정책 및 Realtime 설정**:
      * Flutter 앱은 `anonKey`를 사용하므로, **실시간 읽기(`SELECT`)** 가 작동하려면 RLS 정책이 필요합니다.
      * Supabase SQL 편집기에서 아래 정책을 실행합니다.
        ```sql
        CREATE POLICY "Allow anon read access on campaigns"
        ON campaigns
        FOR SELECT
        USING (true);
        ```
      * **Realtime 발행 설정**:
          * Flutter 앱의 `StreamBuilder`가 실시간 업데이트를 받으려면, `campaigns` 테이블을 Realtime 발행에 추가해야 합니다.
        <!-- end list -->
        ```sql
        ALTER PUBLICATION supabase_realtime ADD TABLE campaigns;
        ```
3.  **테스트 시나리오**:
      * **1단계 (실시간 수신)**: Flutter 앱을 실행하고 빈 대시보드 화면을 확인합니다.
      * **2단계 (수신)**: Supabase 대시보드(웹)에서 `campaigns` 테이블에 `s3_key='test.json'`, `status='pending_approval'`로 레코드를 수동 삽입합니다.
      * **3단계 (확인)**: Flutter 앱이 **새로고침 없이** 즉시 "test.json" 항목을 `ListTile`에 표시하는지 확인합니다.
      * **4.단계 (HITL)**: 해당 항목을 탭하여 `DetailScreen`으로 이동한 뒤, [✅ 1차 승인] 버튼을 클릭합니다.
      * **5단계 (완료)**: `DetailScreen`이 닫히고 `HomeScreen`으로 복귀하는지, (n8n이 아직 없으므로) `campaigns` 테이블의 상태는 그대로인지 확인합니다. (17차시에서 n8n이 이 상태를 변경할 것입니다.)

#### 6\. 에러 처리 및 예외 상황 (신규)

  * **🎯 목표**: 데이터가 없거나 예상치 못한 상황에서도 앱이 안정적으로 동작하도록 방어적 코딩을 구현합니다.
  * **주요 시나리오**:
    1.  **S3에 파일이 있지만 Supabase `campaigns` 테이블에 데이터가 없는 경우**:
          * **원인**: Agent 1이 아직 S3 파일을 분석하지 않았거나, Agent 1이 실행되지 않은 상태
          * **처리**: 빈 리스트 상태로 표시하며, 사용자에게 "S3에 파일이 있어도 Agent 1이 분석하기 전까지는 대시보드에 표시되지 않습니다." 안내 메시지 표시
          * **UX**: 아이콘과 함께 명확한 안내 문구 제공
    2.  **`campaigns` 테이블의 필수 필드가 `null`인 경우**:
          * **`status`가 `null`**: 기본값 'unknown' 사용
          * **`s3_key`가 `null`**: 기본값 'Unknown' 또는 'N/A' 사용
          * **`ai_analysis`가 `null`**: "AI 분석 데이터가 아직 없습니다..." 안내 메시지 표시
    3.  **JSON 파싱 실패**:
          * `ai_analysis`가 유효하지 않은 JSON 형식인 경우, 원본 데이터를 문자열로 표시
          * try-catch로 예외 처리하여 앱 크래시 방지
    4.  **네트워크 오류**:
          * Supabase 연결 실패 시 에러 메시지 표시 (빨간색 텍스트)
          * StreamBuilder의 `snapshot.hasError`로 처리
          * 초기화 실패 시 에러 화면 표시 (에러 아이콘, 메시지, 확인 사항 체크리스트)
    5.  **빈 데이터베이스**:
          * `campaigns` 테이블이 완전히 비어있는 경우, 빈 리스트 상태로 처리하여 "대기 중인 캠페인이 없습니다." 메시지 표시
  * **구현 원칙**:
      * 모든 nullable 필드에 대해 null 체크 및 기본값 제공
      * JSON 파싱 시 try-catch 사용
      * 사용자에게 명확한 피드백 제공 (에러 메시지, 안내 문구)
      * 앱이 크래시하지 않도록 방어적 코딩

-----

## 🏁 16차시 준비 완료

모든 준비가 끝났습니다. 17차시를 시작하기 전, 현재 상태는 다음과 같습니다.

  * **S3 버킷 (`campaign-briefs/new/`)**: 16-3에서 제출한 **'정량 목표'가 포함된** 테스트 브리프 JSON 파일 2개가 업로드되어 17차시 '폴링' 감지를 기다리고 있습니다.
  * **Telegram 봇**: 17차시 n8n Agent가 알림을 보낼 준비가 되었습니다.
  * **Supabase DB**:
      * `youtubers` 테이블에 **단가, CPM, CTR, 인구통계** 데이터 셋업이 완료되었습니다.
      * `documents` 테이블에 10명의 RAG 벡터 데이터 셋업이 완료되었습니다.
      * `campaigns` 테이블은 비어 있으며, 17차시 Agent의 상태 기록을 기다리고 있습니다.
      * **RLS 정책**: `campaigns` 테이블에 anon 사용자 읽기 권한 정책이 설정되었습니다.
      * **Realtime 발행**: `campaigns` 테이블이 `supabase_realtime` 발행에 추가되어 Flutter 앱이 실시간 업데이트를 받을 수 있습니다.
  * **광고주 클라이언트 (Next.js)**: Vercel에 배포되어 **'정량 목표'** 를 입력받을 수 있습니다.
  * **관리자 클라이언트 (Flutter)**: Supabase 실시간 연동이 완료되었으며, 17차시 Agent의 상태 변경을 모니터링할 준비가 되었습니다.
      * **Realtime 구독**: `campaigns` 테이블의 변경사항이 앱에 자동으로 반영됩니다 (새로고침 불필요).
 * **PDF 백엔드 서버 (13차시)**: Render/Cloud Run에 배포된 PDF 생성 서버가 17차시 Agent의 호출을 기다리고 있습니다.

> **[중요] 13차시 백엔드 수정 필요**
>
> 17차시의 Agent 3는 계약서를 **Markdown** 형식(`markdownContent`)으로 백엔드에 전송합니다. 하지만 13차시의 원본 백엔드 서버(`server.js`)는 `items` 배열 형태의 JSON만 처리할 수 있습니다.
>
> 따라서 17차시를 진행하기 전, `13차시`의 `server.js`가 **Markdown을 입력받아 HTML로 변환**할 수 있도록 (`marked` 라이브러리 사용 등) 반드시 **사전 수정 및 재배포**가 필요합니다.
