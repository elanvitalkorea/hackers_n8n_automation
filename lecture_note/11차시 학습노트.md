## 11-1차시 학습 노트: React, Next.js, TypeScript 핵심 마스터

### 1\. 오프닝

안녕하세요, 여러분. 지난 차시까지 우리는 n8n을 이용해 강력한 자동화 백엔드 워크플로우를 구축했습니다. 하지만 이 강력한 기능을 사용자가 쉽게 쓰려면 어떻게 해야 할까요? 바로 **전문적인 프론트엔드**(웹 앱) 가 필요합니다.

이번 차시에서는 n8n 프로젝트의 '얼굴'을 만들어 줄 현대 웹 개발의 표준, **React**와 **Next.js**에 대해 알아봅니다. Cursor AI를 활용해 실제 코드를 보면서 이 개념들이 어떻게 유기적으로 동작하는지 살펴보겠습니다.

-----

### 2\. React 소개 및 핵심 개념

#### ▶️ **React 소개
![[Pasted image 20251110192848.png|75]]
  * **React란?**
      * Facebook(Meta)에서 만든, **사용자 인터페이스(UI)를 구축하기 위한 JavaScript 라이브러리**입니다.
  * **핵심 특징: 컴포넌트 기반 아키텍처 (CBA)**
      * React의 모든 것은 '컴포넌트'라는 조각으로 이루어집니다.
      * **[비유]  LEGO 블록:**
          * '버튼', '검색창', '프로필 사진' 같은 작은 LEGO 블록(컴포넌트)을 미리 만듭니다.
          * 이 블록들을 조립해서 '헤더', '사이드바'를 만들고, 이 더 큰 블록들을 모아 '유튜브 페이지'라는 하나의 거대한 구조물을 완성하는 것과 같습니다.
  * **장점:**
      * **재사용성 (Reusability):** `LikeButton` 컴포넌트 하나를 만들어두면, 수천 개의 게시물에 재사용할 수 있습니다.
      * **선언형 (Declarative):** "데이터가 'A' 상태일 때 이 UI를 보여줘"라고 선언만 하면, React가 알아서 화면을 변경합니다. (과거의 `document.getElementById` 같은 복잡한 DOM 조작이 불필요)

< 트위터 예시 >
![[Pasted image 20251110193156.png|650]]

#### ▶️ **React 핵심 개념 (3분)**


1.  **Props (Properties)**
      * **개념:** 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 **읽기 전용** 값입니다.
      * **[비유] 함수의 인자(Argument):**
      * **[코드 예시]**
          * 부모 `App.jsx`가 `<Welcome name="홍길동" />`을 호출합니다.
          * 자식 `Welcome.jsx`은 `props.name`으로 "홍길동"을 받아 `<h1>안녕하세요, 홍길동님</h1>`을 그립니다.
          * `Welcome` 컴포넌트는 `name`을 바꿀 수 없습니다. 부모만 줄 수 있습니다.

2.  **State (State)**
      * **개념:** 컴포넌트가 **자체적으로 관리하는 내부 데이터**입니다. 이 값이 변하면 React가 자동으로 UI를 다시 그립니다(Re-render).
      * **[비유] 컴포넌트의 개인 메모리:**
      * **[코드 예시]**
        ```jsx
        import React, { useState } from 'react';

        function Counter() {
          const [count, setCount] = useState(0); // 0에서 시작하는 'count'라는 state

          return (
            <div>
              <p>카운트: {count}</p>
              {/* 버튼 클릭 시 setCount가 state를 변경 -> React가 UI를 새로고침 */}
              <button onClick={() => setCount(count + 1)}>증가</button>
            </div>
          );
        }
        ```
      * `LikeButton`이 '좋아요' 개수를 기억하는 것이 바로 이 `state` 덕분입니다.

-----

### 3\. Next.js와 TypeScript

#### ▶️ **Next.js 소개 및 TypeScript (2분)**

  * **Next.js란?**
      * \*\*"React를 위한 프레임워크"\*\*입니다.
      * **[비유] React가 '엔진'이라면, Next.js는 '완성된 자동차'입니다.**
      * React(엔진)만으로는 자동차를 만들 수 없습니다. Next.js는 React에 라우팅, 서버 렌더링, API 기능 등을 추가하여 완성차를 만듭니다.
  * **핵심 특징: 풀스택(Full-Stack) 프레임워크**
      * 이것이 n8n 과정에 Next.js를 쓰는 이유입니다. 프론트엔드(`page.tsx`)와 백엔드(`route.ts`)를 하나의 프로젝트에서 모두 개발할 수 있습니다.
  * **TypeScript 기본 지원**
      * **TypeScript란?** JavaScript에 '타입(Type)'을 추가한 언어입니다. "JavaScript + Types".
      * **Next.js가 TS를 사랑하는 이유:**
        1.  **버그 사전 방지:** 코드를 실행하기 *전*에 타입 오류를 잡아줍니다.
        2.  **IDE 기능 극대화:** Cursor AI나 VSCode에서 **자동완성**과 **디버깅**이 완벽해집니다.
	- **실용적 예제** (Cursor AI로 미리 만든 코드):
		- JS 버전 (오류 발생 가능):
		  ```js
		  function greet(name) {
		    return "Hello, " + name.toUpperCase(); // name이 string이 아니면 런타임 오류
		  }
		  greet(123); // 런타임에서만 오류
		  ```
		- TS 버전 (컴파일 시 오류 잡음):
		  ```ts
		  function greet(name: string): string {
		    return `Hello, ${name.toUpperCase()}`; // 자동완성: toUpperCase() 제안
		  }
		  greet(123); // 컴파일 오류: Argument of type 'number' is not assignable to 'string'
		  ```
.

#### ▶️ **Next.js 핵심 개념 (7분)**


 #####  **1. App Router (파일 시스템 기반 라우팅)**

* **[전통 방식]** (React Router) 별도 설정 파일에 `<Route path="/about" ...>`처럼 수동으로 경로를 등록해야 했습니다.
* **[Next.js 방식]** **설정 파일이 없습니다.** **폴더 구조가 곧 URL입니다.**
* **[코드 예시]**
	* `src/app/page.tsx` → `/` (메인 페이지)
	* `src/app/about/page.tsx` → `/about` (소개 페이지)
	* `src/app/api/likes/route.ts` → `/api/likes` (API 엔드포인트)
* **장점:** 직관적이고, 설정이 필요 없습니다.

![[Pasted image 20251023103555.png]]

 ##### **2. 서버 컴포넌트 (RSC) vs 클라이언트 컴포넌트**

* **[개요]** Next.js 13+의 가장 혁신적인 기능입니다.
* **서버 컴포넌트 (기본값):**
	* `page.tsx`처럼 `"use client"`가 없는 모든 컴포넌트입니다.
	* **특징:** 코드가 **서버에서만** 실행됩니다.
	* **장점 1 (보안):** DB 접속 키, API 키를 코드에 직접 써도 **클라이언트에 절대 노출되지 않습니다.** (첨부 파일 `page.tsx`의 `getPosts` 함수 참조)
	* **장점 2 (성능):** 서버에서 데이터를 가져와 HTML로 미리 렌더링한 후 클라이언트에 보냅니다. 초기 로딩이 빠르고 SEO에 유리합니다.
* **클라이언트 컴포넌트 (선택):**
	* **특징:** 파일 최상단에 `"use client";`를 선언합니다.
	* **이유:** `useState`, `useEffect`, `onClick` 등 **사용자 상호작용**이 필요할 때 사용합니다.
	* **[코드 예시]** (첨부 파일 `LikeButton.tsx` 참조)
	  * '좋아요' 버튼은 클릭(`onClick`)되어야 하고, `state`를 가져야 하므로 반드시 `"use client";`여야 합니다.
* **[핵심]** "데이터 패치와 보안은 서버 컴포넌트가, 클릭과 인터랙션은 클라이언트 컴포넌트가 담당한다."
![[Pasted image 20251023103057.png]]
 ##### **3. 렌더링 전략: SSG, SSR, ISR**

* Next.js가 데이터를 언제 렌더링할지 결정하는 방식입니다. `fetch` 옵션으로 간단히 제어합니다.
* **SSG (Static Site Generation):**
	* `fetch(..., { cache: 'force-cache' })` (기본값)
	* **언제:** 빌드 시 (배포 시 1번)
	* **장점:** 가장 빠름 (미리 만들어둔 HTML 파일 서빙)
	* **용도:** 블로그, 소개 페이지 (내용이 잘 안 바뀌는 곳)
* **SSR (Server-Side Rendering):**
	* `fetch(..., { cache: 'no-store' })` (우리 프로젝트 `page.tsx`가 사용 중)
	* **언제:** 요청 시 (새로고침 할 때마다)
	* **장점:** 항상 최신 데이터 보장
	* **용도:** 대시보드, 쇼핑몰 장바구니
* **ISR (Incremental Static Regeneration):**
	* `fetch(..., { next: { revalidate: 3600 } })`
	* **언제:** 빌드 시 1번 + 3600초(1시간)마다 갱신
	* **장점:** SSG의 속도 + SSR의 최신성 (하이브리드)
	* **용도:** 뉴스 사이트 (1시간마다 기사 갱신)

![[Pasted image 20251023103150.png]]

#### ▶️ Next.js 4가지 렌더링 방식 비교

##### 📊 4가지 비교표 - Network 탭 기준

| 방식      | **HTML 크기**   | **JS 크기** | **최초 로딩** | **서버 부하** | **데이터 최신성** | **용도** |
| ------- | ------------- | --------- | --------- | --------- | ----------- | ------ |
| **CSR** | 2KB (빈)       | **80KB**  | **2초**    | 낮음        | 요청 시        | SPA 앱  |
| **SSR** | **15KB (완성)** | 20KB      | **200ms** | **높음**    | **항상 최신**   | 대시보드   |
| **SSG** | **15KB (완성)** | **15KB**  | **50ms**  | **0**     | 빌드 시        | 블로그    |
| **ISR** | **15KB (완성)** | **15KB**  | **50ms**  | **매우 낮음** | **1시간 최신**  | 뉴스     |

##### 📁 프로젝트 구조 (모두 동일)
```
src/app/blog/page.tsx
src/app/blog/[id]/page.tsx
```

##### 1. CSR (Client-Side Rendering)

###### 코드
```tsx
// src/app/blog/page.tsx
"use client";  // ← 이 한 줄로 CSR!

export default function BlogPage() {
  const [posts, setPosts] = useState([]);

  useEffect(() => {
    fetch('/api/posts').then(res => res.json()).then(setPosts);
  }, []);

  return <div>{posts.map(post => <div>{post.title}</div>)}</div>;
}
```

###### Network 탭
```
GET /blog                       (2KB)   ← 빈 HTML
GET /_next/static/.../blog.js   (80KB)  ← 컴포넌트 + fetch 로직
```

###### 브라우저 받는 HTML
```html
<!-- 빈 껍데기 -->
<div id="__next">
  <div></div>  <!-- 데이터 없음 -->
</div>
```

###### 타임라인
```
1. 빈 HTML 표시 (0.1초)
2. JS 다운로드 (80KB)
3. fetch('/api/posts') 실행 (서버 요청)
4. 데이터 도착 → 렌더링 (총 2초)
```

##### 2. SSR (Server-Side Rendering)

###### 코드
```tsx
// src/app/blog/page.tsx (기본값)
export default async function BlogPage() {
  const posts = await fetch('https://api/posts', {
    cache: 'no-store'  // 매 요청마다 새로고침
  }).then(res => res.json());

  return (
    <div>
      {posts.map(post => <div>{post.title}</div>)}
    </div>
  );
}
```

###### Network 탭
```
GET /blog                       (15KB)  ← 완성 HTML + 데이터
GET /_next/static/...           (20KB)  ← Hydration JS
```

###### 브라우저 받는 HTML
```html
<!-- 데이터 포함! -->
<div id="__next">
  <div>포스트 제목 1</div>
  <div>포스트 제목 2</div>
</div>
```

##### 3. SSG (Static Site Generation) - 빌드 시 미리 생성

###### 코드
```tsx
// src/app/blog/page.tsx
export default async function BlogPage() {
  const posts = await fetch('https://api/posts', {
    cache: 'force-cache'  // 빌드 시 1번만
  }).then(res => res.json());

  return (
    <div>
      {posts.map(post => <div>{post.title}</div>)}
    </div>
  );
}
```

###### Network 탭
```
GET /blog                       (15KB)  ← **미리 만들어진 정적 HTML**
GET /_next/static/...           (15KB)  ← 최소 JS
```

###### 브라우저 받는 HTML
```html
<!-- 빌드 시 생성된 완성 HTML -->
<div id="__next">
  <div>포스트 제목 1</div>
  <div>포스트 제목 2</div>
</div>
```

###### 🔥 차이점
- **서버 부하 0**: `.html` 파일을 **CDN에서 즉시 서빙**
- **최고 속도**: **50ms** 로딩 (캐시된 파일)
- **View Source**: **완벽한 완성 HTML**

##### 4. ISR (Incremental Static Regeneration) - 하이브리드

###### 코드
```tsx
// src/app/blog/page.tsx
export default async function BlogPage() {
  const posts = await fetch('https://api/posts', {
    next: { revalidate: 3600 }  // 1시간마다 갱신
  }).then(res => res.json());

  return (
    <div>
      {posts.map(post => <div>{post.title}</div>)}
    </div>
  );
}
```

###### Network 탭
```
GET /blog                       (15KB)  ← **캐시된 HTML** (1시간 유효)
GET /_next/static/...           (15KB)
```

###### 실제 동작
```
1. 첫 방문: SSG처럼 빌드된 HTML 서빙 (50ms)
2. 1시간 후: 백그라운드에서 새 데이터로 HTML 재생성
3. 다음 방문자: **최신 데이터** 받은 HTML 서빙
```

###### 🔍 확인법
```
curl -I /blog
Cache-Control: s-maxage=3600, stale-while-revalidate
```



---


### 4\. Next.js API Route

#### ▶️ **API Route의 장점 (2분)**

  * **개념:** 프론트엔드 프로젝트 내부에 **서버리스 백엔드 API**를 만드는 기능입니다.
  * **[코드 예시]**
      * `src/app/api/likes/route.ts` 파일을 만들기만 하면 `/api/likes` API가 즉시 생성됩니다.
  * **장점 (Express.js 대비):**
    1.  **하나의 프로젝트:** 별도 Express 서버를 만들 필요가 없습니다. (개발 속도 5배 향상)
    2.  **CORS 문제 자동 해결:** 같은 도메인에서 요청하므로 **CORS 설정이 0줄**입니다.
    3.  **완벽한 보안:** 이곳은 **서버 전용** 공간입니다. n8n 웹훅 URL, Supabase 키, Upstage OCR API 키 등 민감한 정보를 `process.env`로 안전하게 숨길 수 있습니다.
  * **[우리 프로젝트]**
      * `LikeButton` (클라이언트) → `fetch('/api/likes')` 호출
      * `route.ts` (서버) → 요청을 받아 n8n 웹훅을 트리거하거나 DB를 업데이트

![[Pasted image 20251023103809.png]]

-----

### 5. 🚀 Next.js UX 개발 진화 3단계 ( tailwind -> shadcn)

Next.js로 웹을 만들 때, UI/UX를 구현하는 방식은 크게 3단계를 거쳐 발전해 왔습니다. 각 단계는 이전 단계의 핵심 문제를 해결하며 생산성을 극대화하는 방향으로 진화합니다.

-----

#### 1단계: Next.js + 일반 CSS (기본 방식)

첫 번째 단계는 Next.js(React) 컴포넌트와 별도의 `.css` 파일을 사용하는 전통적인 방식입니다.

##### 구현 방식

  * `PostItem.tsx` 컴포넌트 작성: `className="post-card"`처럼 의미론적 클래스 이름을 지정합니다.
  * `common.css` 파일 작성: `.post-card { ... }`, `.post-card:hover { ... }` 등 모든 스타일을 별도 파일에 정의합니다.

##### 😭 핵심 문제점: "파일 전환 지옥"

  * **컨텍스트 스위칭:** 스타일을 확인하거나 수정하려면 `PostItem.tsx` 파일과 `common.css` 파일을 계속 번갈아 열어야 합니다.
  * **클래스 이름 고민:** `.post-card`로 할지, `.article-item`으로 할지 등 클래스 이름을 짓는 데 시간이 소요됩니다.
  * **CSS 파일 비대화:** 프로젝트가 커지면 `common.css` 파일은 수백, 수천 줄이 되며, 사용하지 않는 "죽은 코드(Dead code)"를 관리하기 어렵습니다. (예제에서 177줄 발생)
  * **유지보수:** `.like-button`과 유사한 `.dislike-button`을 만들려면 CSS 코드를 대부분 복사/붙여넣기 해야 합니다.

-----

#### 2단계: Next.js + Tailwind CSS (혁신)

두 번째 단계는 CSS 파일을 없애고, 모든 스타일을 JSX/TSX 파일 내에서 직접 정의하는 **"Utility-First(유틸리티 우선)"** 방식입니다.

##### 구현 방식

  * `common.css` 파일을 **삭제**합니다.
  * `PostItem.tsx`에 직접 스타일을 작성합니다.
  * `<article className="p-6 bg-white border rounded-xl shadow-md ...">`처럼 미리 정의된 유틸리티 클래스를 조합해 스타일을 완성합니다.

##### ✨ 해결된 점

  * **파일 전환 제로:** CSS 파일을 열 필요 없이, `PostItem.tsx` 파일 하나만 보면 구조와 스타일이 한눈에 보입니다.
  * **클래스 이름 불필요:** `p-6`는 항상 `padding: 24px`입니다. 고민이 필요 없습니다.
  * **빠른 반응형/상태 처리:** `hover:shadow-lg`, `md:p-8`, `dark:bg-gray-800`처럼 접두사(prefix)만으로 호버, 반응형, 다크 모드를 즉시 구현합니다.
  * **Dead Code 없음:** 빌드 시 실제 사용한 클래스만 추출하므로 최종 CSS 파일 크기가 매우 작습니다.

##### 😭 새로운 문제점: "클래스 문자열 지옥"

  * **가독성 저하:** `LikeButton` 예제처럼 버튼 하나에 30개가 넘는 클래스가 붙으면 `className` 문자열이 160자가 넘어갈 정도로 길어집니다.
  * **코드 중복:** Tailwind가 CSS 중복은 해결했지만, 이제 **JSX의 `className` 중복**이 발생합니다. 비슷한 버튼을 만들려면 이 160자짜리 문자열을 복사/붙여넣기 해야 합니다.

-----

#### 3단계: Next.js + Tailwind + shadcn/ui (추상화)

세 번째 단계는 Tailwind의 긴 클래스 문자열을 의미론적이고 재사용 가능한 \*\*"컴포넌트"\*\*로 추상화하는 방식입니다. shadcn/ui는 라이브러리가 아니라, 잘 만들어진 컴포넌트 코드를 **내 프로젝트에 복사**해오는 방식입니다.

##### 구현 방식

  * `PostItem.tsx`에서 25개의 Tailwind 클래스 대신, shadcn/ui의 `<Card>` 컴포넌트를 사용합니다.

  * `LikeButton.tsx`에서 30개의 Tailwind 클래스 대신, `<Button>` 컴포넌트를 사용합니다.

    ```tsx
    // ❌ 2단계 (Tailwind)
    <article className="p-6 bg-white border border-gray-200 rounded-xl shadow-md ...">
      <h2 className="text-2xl font-bold text-gray-800 ...">{post.title}</h2>
      ...
    </article>

    // ✅ 3단계 (shadcn/ui)
    <Card className="hover:shadow-md">
      <CardHeader>
        <CardTitle>{post.title}</CardTitle>
      </CardHeader>
      ...
    </Card>
    ```

##### ✨ 모든 문제 해결

  * **최고의 가독성:** `<Card>`, `<Button>` 등 의미가 명확한 컴포넌트를 사용합니다.
  * **완벽한 재사용:** `variant="destructive"` (빨간 버튼), `size="lg"` (큰 버튼)처럼 `prop`으로 스타일을 쉽게 제어합니다.
  * **중앙 관리:** 버튼 스타일을 변경하고 싶다면, `src/components/ui/button.tsx` 파일 **한 곳만** 수정하면 앱 전체의 모든 버튼이 변경됩니다.

##### 🚀 shadcn/ui의 진짜 가치: 복잡한 컴포넌트

  * `Card`나 `Button`은 직접 만들 수도 있습니다.
  * 하지만 **`<Dialog>`(모달), `<Select>`, `<Dropdown>`** 등은 다릅니다.
  * shadcn/ui는 **Radix UI**를 기반으로 하여, 키보드 네비게이션, 포커스 관리, ARIA 속성 등 **웹 접근성(Accessibility)** 이 완벽하게 구현된 복잡한 컴포넌트들을 제공합니다.
  * 개발자는 100줄 넘게 직접 구현할 필요 없이, 이미 검증된 컴포넌트를 즉시 사용할 수 있습니다.

-----

#### 📊 최종 요약: 진화의 여정

1.  **Next.js (기본):** 스타일과 구조가 **분리**되어 개발 속도가 느리고 CSS 관리가 어렵습니다.
2.  **+ Tailwind:** 스타일과 구조를 **통합**하여 파일 전환이 사라지고 개발 속도가 빨라집니다. (단점: `className`이 복잡해짐)
3.  **+ shadcn/ui:** Tailwind의 복잡한 클래스를 **추상화**하여, **재사용 가능**하고 **웹 접근성**이 완벽한 컴포넌트 기반으로 개발합니다.

이 3단계 스택(Next.js + Tailwind + shadcn/ui)이 현재 가장 생산성 높은 모던 프론트엔드 개발 표준으로 자리 잡고 있습니다.

-----

## 11-2차시 학습 노트: 강의 사용자 만족도 앱 만들기

### 1\. 오프닝

안녕하세요, 여러분. 11-1차시에서 React, Next.js, TypeScript의 핵심 이론을 배웠습니다. 이제 배운 이론을 바탕으로 실제 **'강의 만족도 조사 웹 애플리케이션'** 을 만들어 볼 차례입니다.

이번 차시에서는 Cursor AI와 함께 기획(PRD)부터 Supabase 백엔드 설정, 그리고 Next.js 풀스택 코드까지 전체 프로젝트를 완성해 보겠습니다.

-----

### 2\. 프로젝트 기획(PRD) 리뷰

모든 개발의 시작은 '무엇을 만들 것인가'를 정의하는 기획입니다. 우리는 이 기획 문서를 \*\*PRD (Product Requirements Document, 제품 요구사항 정의서)\*\*라고 부릅니다.



▶️ **우리 앱의 핵심 요구사항 (PRD 요약)**

  * **프로젝트 목표:** 강의 만족도 데이터를 수집하고(설문 폼), 실시간으로 시각화(대시보드)합니다.
  * **기술 스택:** Next.js (App Router), Tailwind CSS, Supabase (DB/Functions), n8n (자동화).
  * **주요 페이지:**
      * **`/` (메인 페이지):** 설문 폼. SSG (Static Site Generation)로 빌드 시 정적 생성하여 가장 빠른 로딩 속도를 보장합니다.
      * **`/stats` (통계 페이지):** 실시간 대시보드. ISR (Incremental Static Regeneration)을 사용해 60초마다 데이터를 갱신합니다. (PRD 기획은 10초였으나, 최종 코드에서 60초로 확정되었습니다.)
  * **핵심 API:**
      * `POST /api/submit`: 설문 제출용.
      * `GET /api/stats`: 통계 데이터 조회용.
  * **데이터베이스 전략:**
      * **테이블 1개:** `surveys` 테이블 하나만 운영합니다.
      * **SQL 함수 2개:** 모든 집계(NPS, 통계)는 DB 성능을 활용하기 위해 Supabase의 SQL 함수(RPC)로 처리합니다.

-----

### 3\. Supabase 백엔드 셋업 (Schema & Functions)

Next.js 앱을 만들기 전, 데이터를 저장할 Supabase 백엔드를 먼저 설정합니다.

▶️ **1. 테이블 스키마 (`surveys`)**
PRD에 정의된 대로, 설문 데이터를 저장할 `surveys` 테이블을 생성합니다.

  * `name`, `phone`, `company_email`, `position`, `company_size` 등 사용자 정보
  * `satisfaction` (1-10점 만족도)
  * `comment` (선택적 코멘트)

▶️ **2. 핵심 SQL 함수 (RPC)**
왜 API 서버(Next.js)가 아닌 DB(Supabase)에서 계산할까요? **성능** 때문입니다. 수만 건의 데이터를 서버로 가져와 계산하는 것보다, DB가 직접 계산한 *결과*만 가져오는 것이 훨씬 빠릅니다.

  * **`calculate_current_nps()`**

      * **역할:** 실시간 NPS 점수를 계산합니다. (NPS = 추천자 % - 비추천자 %)
      * **사용처:** `POST /api/submit` API가 n8n으로 웹훅을 보낼 때 현재 NPS 점수를 함께 보내기 위해 사용합니다.

  * **`get_dashboard_stats()`**

      * **역할:** `/stats` 대시보드에 필요한 모든 통계(총 응답자, NPS 점수, 직책 분포, 회사 규모 분포)를 **단 하나의 JSON 객체**로 묶어서 반환합니다.
      * **성능 이점:** 이 함수 하나만 호출하면 되므로 API가 DB에 여러 번 요청할 필요가 없습니다.

-----

### 4\. Next.js 풀스택 코드 리뷰

이제 `repomix`의 코드를 통해 Next.js 앱이 어떻게 이 백엔드와 연동되는지 확인합니다.

▶️ **1. 백엔드: API Routes (`src/app/api/...`)**

  * **`POST /api/submit/route.ts` (설문 제출)**

    1.  **데이터 수신:** `await request.json()`으로 사용자 폼 데이터를 받습니다.
    2.  **유효성 검사:** `validateEmail`, `validatePhone` (`lib/validation.ts`) 함수로 이메일, 전화번호 형식을 검사합니다.
    3.  **DB 저장:** `supabase.from('surveys').insert(...)`로 Supabase에 데이터를 저장합니다.
    4.  **NPS 조회:** `supabase.rpc('calculate_current_nps')`를 호출하여 현재 NPS 점수를 가져옵니다.
    5.  **n8n 연동:** `N8N_WEBHOOK_URL`로 `{ name, phone, nps_score }`가 포함된 웹훅을 `fetch`로 전송합니다. (이것이 11-4차시에서 다룰 자동화의 시작점입니다\!)

  * **`GET /api/stats/route.ts` (통계 조회)**

    1.  **RPC 호출:** `supabase.rpc('get_dashboard_stats')` 함수를 호출합니다.
    2.  **데이터 반환:** DB가 반환한 JSON 객체를 `NextResponse.json(data)`로 클라이언트에 그대로 전달합니다.

▶️ **2. 프론트엔드: Pages (`src/app/...`)**

  * **`/page.tsx` (설문 폼)**

      * **`"use client";`**: `useState` (폼 데이터 관리), `useRouter` (페이지 이동) 등 사용자 상호작용이 필요하므로 클라이언트 컴포넌트로 선언합니다.
      * **`handleSubmit` 함수:** 폼 유효성 검사(`validateForm`) 후, `POST /api/submit`에 `fetch` 요청을 보냅니다.
      * **성공 시:** `router.push('/stats')`를 통해 통계 페이지로 이동시킵니다.

  * **`/stats/page.tsx` (대시보드 - 서버 컴포넌트)**

      * **`"use client"` 없음\!** 이 페이지는 기본적으로 \*\*서버 컴포넌트(RSC)\*\*입니다.
      * **`async function getStats()`:** 서버에서 직접 `fetch`를 통해 `GET /api/stats` API를 호출합니다.
      * **`next: { revalidate: 60 }`:** **ISR** 설정입니다. 60초마다 이 페이지는 서버에서 자동으로 데이터를 갱신합니다.
      * **`<StatsClient stats={stats} />`:** 서버에서 가져온 `stats` 데이터를 클라이언트 컴포넌트인 `StatsClient`에 `props`로 내려줍니다.

  * **`/stats/StatsClient.tsx` (대시보드 - 클라이언트 컴포넌트)**

      * **`"use client";`**: `recharts` 라이브러리(BarChart, PieChart)는 브라우저에서 동적으로 그려져야 하므로 클라이언트 컴포넌트로 선언합니다.
      * RSC(데이터)와 클라이언트 컴포넌트(UI)의 완벽한 조합입니다.

-----

### 5\. 개발 시 유의사항 및 데모

  * **개발 유의사항:**
      * Tailwind CSS나 shadcn/ui 같은 라이브러리는 버전업이 매우 빠릅니다. 강의 시점의 코드도 중요하지만, **항상 최신 공식 문서를 참조**하는 습관이 중요합니다. (`use context7` -\> 최신 context/문서 활용으로 해석)
  * **데모:**
      * Cursor AI의 터미널에서 `npm run dev`를 실행합니다.
      * Cursor Browser (VSCode 내장 브라우저)를 통해 `http://localhost:3000`에 접속하여 설문을 제출합니다.
      * `/stats` 페이지로 자동 이동되며, 방금 제출한 데이터가 NPS 점수와 차트에 즉시 반영되는 것을 확인합니다.

-----

## 11-3차시 학습 노트: Solapi 셋업 (SMS 자동화)

### 1\. 오프닝

11-2차시에서 설문 앱을 완성했습니다. 이제 11-4차시에서 n8n 워크플로우를 완성하기 전, 사용자에게 "설문 감사합니다" SMS를 보낼 **Solapi** 서비스를 셋업해야 합니다.

이번 차시에서는 n8n과 Solapi를 연동하는 OAuth2 인증 과정을 상세히 다룹니다.

-----

### 2\. Solapi 란?

Solapi는 국내 환경에 최적화된 SMS, 알림톡 발송 API 서비스입니다. n8n 워크플로우에 연동하여 설문 제출자에게 감사 쿠폰 SMS를 발송하는 용도로 사용합니다.

-----

### 3\. n8n - Solapi OAuth2 연동 가이드

n8n에서 Solapi API를 사용하려면 '인증'이 필요합니다. Solapi는 OAuth2 방식을 사용하며, 설정 단계가 조금 복잡하므로 집중해서 따라 해주세요.

▶️ **Step 1: Solapi 가입 및 앱 생성**

1.  Solapi에 회원가입합니다.
2.  `내앱 목록` ([https://console.solapi.com/me/apps)으로](https://console.solapi.com/me/apps)으로) 이동하여 새 앱을 생성합니다.

▶️ **Step 2: n8n에서 Credential 생성 시작**

1.  n8n 대시보드 \> Credentials \> Add Credential
2.  **Authentication:** `Generic Credential Type` 선택
3.  **Generic Auth Type:** `OAuth2 API` 선택
4.  **Grant Type:** `Authorization Code` 선택

▶️ **Step 3: n8n에 Solapi 정보 입력**

  * **Authorization URL:** `https://api.solapi.com/oauth2/v1/authorize`
  * **Access Token URL:** `https://api.solapi.com/oauth2/v1/access_token`

▶️ **Step 4: n8n ↔ Solapi 정보 교환**

1.  **[n8n에서 Solapi로]** n8n Credential 설정 화면에 보이는 `OAuth Redirect URL` (예: `https://[내 n8n주소]/rest/oauth2-credential/callback`)을 복사합니다.
2.  Solapi 앱 설정의 `Redirect URI` 항목에 1번에서 복사한 n8n URL을 붙여넣고 저장합니다.
3.  **[Solapi에서 n8n으로]** Solapi 앱 설정에서 `Client ID`와 `Client Secret`을 복사합니다. (Secret은 생성 시에만 보이므로 반드시 메모해야 합니다.)
4.  n8n Credential 설정 화면으로 돌아와 복사한 `Client ID`와 `Client Secret`을 붙여넣습니다.
5.  **Scope:** `message:send` 등 필요한 권한을 선택합니다. (강의에서는 대부분 선택)

▶️ **Step 5: 인증 완료**

1.  n8n Credential 하단의 'Sign in with Solapi' 버튼을 클릭합니다.
2.  Solapi 로그인 및 권한 승인 창이 뜨면 '허용'을 클릭합니다.
3.  "Connection successfully created." 메시지가 뜨면 인증이 완료된 것입니다.

<!-- end list -->

  * **참조 문서:** [Solapi OAuth2 공식 가이드](https://developers.solapi.com/references/authentication/oauth2-3/oauth2)

-----

## 11-4차시 학습 노트: 시나리오 완성 (n8n 워크플로우)

### 1\. 오프닝

드디어 11차시의 마지막입니다. 11-2에서 만든 Next.js 앱과 11-3에서 셋업한 Solapi 인증을 n8n 워크플로우로 연결하여 전체 자동화 시나리오를 완성합니다.

제공된 n8n 워크플로우 JSON을 분석하며 각 노드가 어떻게 유기적으로 동작하는지 살펴보겠습니다.

-----

### 2\. n8n 워크플로우 전체 흐름

**시나리오:** "사용자가 Next.js 앱에서 설문을 제출하면, n8n이 데이터를 받아 사용자에게는 쿠폰 SMS를 발송하고, 관리자에게는 텔레그램 알림을 보낸다."

-----

### 3\. 노드별 상세 분석

▶️ **1. Webhook 노드 (시작)**

  * **타입:** `Webhook`
  * **역할:** `POST /api/submit` API가 `fetch`로 호출하는 엔드포인트입니다.
  * **수신 데이터 (PinData 기준):** `{ "name": "진주성", "phone": "010-2736-0542", "nps_score": 71.4... }`

▶️ **2. Edit Fields 노드 (데이터 가공)**

  * **타입:** `Set`
  * **역할:** 수신된 데이터를 후속 노드에서 사용하기 쉽게 가공합니다.
  * **주요 작업:**
      * **`name`:** `{{ $json.body.name }}` (이름 변수화)
      * **`phone`:** `{{ $json.body.phone.replaceAll('-','') }}`
          * **(중요\!)** Solapi API는 `010-1234-5678` 형식이 아닌 `01012345678` 형식을 요구할 수 있으므로, `replaceAll` 함수로 `-`를 모두 제거합니다.
      * **`nps_score`:** `{{ $json.body.nps_score }}` (NPS 점수 변수화)
      * **`content`:** `{{ $json.body.name }}님 설문에 응해주셔서 감사합니다. ... 쿠폰코드... N8NELAN20`
          * SMS로 보낼 메시지 본문을 생성합니다. 쿠폰 코드(`N8NELAN20`)가 여기에 포함됩니다.

▶️ **3. Solapi 문자 보내기 노드 (사용자 알림)**

  * **타입:** `HTTP Request`
  * **역할:** 11-3에서 설정한 Solapi OAuth2 인증을 사용해 SMS를 발송합니다.
  * **주요 설정:**
      * **URL:** `https://api.solapi.com/messages/v4/send-many/detail` (Solapi 발송 API)
      * **Authentication:** `Generic Credential Type` - `OAuth2 API` (11-3에서 만든 Solapi Oauth Credential 선택)
      * **JSON Body:**
        ```json
        {
          "messages": [
           {
             "to": "{{ $json.phone }}",  // Edit Fields 노드의 phone 변수
             "from": "01095300542",     // Solapi에 등록된 발신 번호
             "text": "{{ $json.content.replace(/\\n/g, "\\\\n") }}" // Edit Fields의 content 변수
           }
          ]
        }
        ```

▶️ **4. Send a text message 노드 (관리자 알림)**

  * **타입:** `Telegram`
  * **역할:** 설문이 제출되었음을 관리자(나)에게 실시간 알림으로 보냅니다.
  * **주요 설정:**
      * **Chat ID:** `1301607555` (알림을 받을 내 텔레그램 챗 ID)
      * **Text:** `새로운 설문이 제출 되었습니다. ... {{ $('Edit Fields').item.json.name }} 님이 ... NPS Score는 {{ $('Edit Fields').item.json.nps_score }} 입니다.`
          * `$('Edit Fields')` 표현식을 사용해 'Edit Fields' 노드의 데이터를 참조하여 알림 메시지를 동적으로 구성합니다.
