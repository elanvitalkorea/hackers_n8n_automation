
## 12-1 웹앱 배포 (정적 vs 동적)

### 1\. 오프닝

안녕하세요, 여러분. 11차시까지 우리는 Supabase 백엔드와 연동되는 Next.js 풀스택 '강의 만족도 앱'을 완성했습니다. 이제 우리가 만든 이 멋진 웹 애플리케이션을 전 세계 누구나 접속할 수 있도록 인터넷에 '배포'할 차례입니다.

이번 차시에서는 배포의 두 가지 핵심 방식인 **정적(Static) 배포**와 **동적(Dynamic) 배포**의 차이점을 명확히 이해하고, 우리 프로젝트가 어떻게 이 두 가지 방식을 모두 지원하는지 소스 코드를 통해 확인해 보겠습니다.

-----

### 2\. 정적(Static) 배포 vs 동적(Dynamic) 배포

웹 앱을 배포하는 방식은 크게 두 가지로 나뉩니다. 이 둘의 차이를 이해하는 것이 12차시의 가장 중요한 핵심입니다.

#### ▶️ **1. 정적(Static) 배포 (SSG / CSR)**

  * **[비유] 인쇄된 책 📚:**
      * '빌드'라는 인쇄 과정에서 모든 페이지(HTML, CSS, JS)를 미리 다 만들어 버립니다.
      * 사용자가 요청하면, 이미 완성된 파일을 그대로 전달합니다.
  * **특징:**
      * **서버가 필요 없음:** Node.js 같은 서버 없이, 파일을 올려둘 공간만 있으면 됩니다.
      * **빠른 속도:** 이미 완성된 파일을 전 세계 CDN(콘텐츠 전송 네트워크)에 복사해두고 가장 가까운 곳에서 주기 때문에 속도가 매우 빠릅니다.
      * **보안:** 서버 로직이 없으므로 해킹 위험이 적습니다.
  * **우리 프로젝트 적용 (`STATIC_EXPORT=true`):**
      * `next.config.ts`에서 `output: 'export'`가 활성화됩니다.
      * `npm run build:static` 명령을 실행하면, 서버 코드가 모두 제거된 `out/` 폴더가 생성됩니다.
      * **API Routes (`/api/likes`)가 작동하지 않습니다.**
      * `LikeButton.tsx`는 `isStatic` 변수를 감지하여 API 대신 `localStorage`를 사용합니다. (데이터가 사용자 브라우저에만 저장됨)
      * `page.tsx`는 `ClientHomePage`를 export 하여, 브라우저에서 데이터를 fetch하는 CSR(Client-Side Rendering) 방식으로 동작합니다.

#### ▶️ **2. 동적(Dynamic) 배포 (SSR / API Routes)**

  * **[비유] 라이브 뉴스 웹사이트 📰:**
      * 사용자가 요청할 때마다 서버가 실시간으로 최신 뉴스를 조합해 새로운 페이지를 만들어 보여줍니다.
  * **특징:**
      * **서버 필수:** 요청을 처리하고 HTML을 생성할 Node.js 서버가 항상 실행 중이어야 합니다.
      * **최신 데이터:** 항상 최신 데이터를 보여줄 수 있습니다. (e.g., 주식, 대시보드)
      * **API Routes:** `/api/likes` 같은 백엔드 로직이 정상적으로 작동합니다.
  * **우리 프로젝트 적용 (기본값):**
      * `next.config.ts`에서 `output: 'standalone'`이 활성화되어, 서버 실행에 필요한 최소한의 파일로 빌드됩니다.
      * **API Routes (`/api/likes`)가 완벽하게 작동합니다.**
      * `LikeButton.tsx`는 `fetch`를 사용해 실제 서버 API와 통신합니다.
      * `page.tsx`는 `ServerHomePage`를 export 하여, 서버에서 데이터를 미리 가져와 렌더링하는 SSR(Server-Side Rendering) 방식으로 동작합니다.

#### ▶️ **📊 핵심 비교 (우리 프로젝트 기준)**

| 항목            | 정적 배포 (Static)          | 동적 배포 (Dynamic)         |
| ------------- | ----------------------- | ----------------------- |
| **명령어**       | `npm run build:static`  | `npm run build`         |
| **환경 변수**     | `STATIC_EXPORT=true`    | 없음 (기본값)                |
| **배포 대상**     | **GitHub Pages**        | **Vercel, AWS Amplify** |
| **렌더링**       | CSR (클라이언트)             | SSR (서버)                |
| **포스트 로드**    | 로딩 후 표시                 | 즉시 표시                   |
| **API Route** | ❌ **무시 (localStorage)** | ✅ **작동 (서버 공유)**        |
| **빌드 출력**     | `out/`                  | `.next/standalone/`     |
| **SEO**       | ❌ CSR 한계                | ✅ SSR 최적화               |

-----

## 12-2 정적 배포 GitHub Pages

### 1\. 오프닝

12-1차시에서 배운 '정적 배포'를 실습해 볼 시간입니다.

대부분 여러분은 **GitHub**를 코드 저장소(Repository)로 잘 알고 계실 겁니다. **GitHub Pages**는 바로 이 GitHub 안에 내장된 **무료 웹사이트 호스팅 기능**입니다. GitHub 저장소에 있는 HTML, CSS, JavaScript 같은 정적 파일들을 가져와, `https://username.github.io/repo-name`과 같은 실제 인터넷 주소로 게시해 줍니다.

서버 컴퓨터를 따로 마련하거나 복잡한 설정을 할 필요 없이, 저장소의 특정 브랜치(예: `gh-pages`)에 파일을 올리기만 하면 웹사이트가 완성됩니다. 이처럼 서버가 필요 없고 정적 파일만으로 동작하기 때문에, '정적 배포'를 실습하고 개인 포트폴리오나 프로젝트 문서를 배포하는 데 가장 이상적이고 비용 효율적인 방법입니다

-----

### 2\. GitHub Pages 배포 절차

GitHub Pages는 저장소(Repository)를 그대로 웹사이트로 보여주는 무료 호스팅 기능입니다.

#### ▶️ **Step 1: `next.config.ts` 수정 (가장 중요\!)**

GitHub Pages는 `https://username.github.io/repo-name/`처럼 하위 경로(sub-path)에 배포됩니다. 우리 앱이 이 경로를 인식하게 설정해야 합니다.

  * `basePath`: 앱의 기본 경로를 `repo-name`으로 설정합니다. (예: `/next-ts-hands-on`)
  * `assetPrefix`: CSS, JS 같은 정적 파일 경로도 동일하게 설정합니다.
  * **이유:** 이 설정을 안 하면, 앱은 `https://username.github.io/` (루트)에서 `_next/static/...` 파일을 찾으려 해서 404 에러가 발생합니다.

<!-- end list -->

```typescript
// next.config.ts
const nextConfig: NextConfig = {
  ...(isStaticExport && {
    output: 'export',
    basePath: '/next-ts-hands-on',       // 👈 본인 리포지토리 이름
    assetPrefix: '/next-ts-hands-on',   // 👈 본인 리포지토리 이름
    images: { unoptimized: true },      // 👈 정적 배포 시 필수
    ...
  }),
  ...
};
```

#### ▶️ **Step 2: API Route 수정 (빌드 에러 방지)**

정적 배포는 서버 코드를 지원하지 않습니다. `force-dynamic`으로 설정된 API Route가 있으면 빌드 에러가 발생합니다.

  * `src/app/api/likes/route.ts` 파일의 `dynamic` 설정을 `force-static`으로 변경해야 합니다.
  * 이렇게 하면 Next.js가 빌드 시 이 API를 무시하고, `LikeButton`은 자동으로 `localStorage` 폴백(fallback) 로직을 사용하게 됩니다.

<!-- end list -->

```typescript
// src/app/api/likes/route.ts

// 🔹 Static 모드 배포 (GitHub Pages):
//    export const dynamic = 'force-static';  // 👈 이렇게 변경
export const dynamic = 'force-dynamic';
```

#### ▶️ **Step 3: `public/.nojekyll` 파일 생성 (필수 Gotcha\!)**

  * **문제:** GitHub Pages는 기본적으로 Jekyll이라는 도구로 사이트를 만드는데, Jekyll은 `_`로 시작하는 폴더(예: `_next`)를 무시합니다.
  * **해결:** `public` 폴더에 `.nojekyll`이라는 빈 파일을 생성하면 Jekyll이 비활성화되어 `_next` 폴더가 정상적으로 배포됩니다.
  * `touch public/.nojekyll` 명령으로 생성할 수 있습니다.

#### ▶️ **Step 4: 배포 스크립트 실행**

우리 `package.json`에는 정적 배포를 위한 스크립트가 이미 준비되어 있습니다.

```json
// package.json
"scripts": {
  "build:static": "STATIC_EXPORT=true NEXT_PUBLIC_STATIC_EXPORT=true next build",
  "deploy:static": "gh-pages -d out -t"
},
```

  * `build:static`: 정적 빌드를 실행합니다.
  * `deploy:static`: `gh-pages`라는 도구를 사용해 `out/` 폴더의 내용을 `gh-pages` 브랜치에 푸시합니다.
      * **`-t` 옵션:** `.nojekyll` 같은 dotfiles(점 파일)을 포함시키기 위해 필수입니다.

<!-- end list -->

```bash
# 터미널에서 이 명령 하나만 실행하면 됩니다.
npm run deploy:static
```

#### ▶️ **Step 5: GitHub Pages 설정**

1.  GitHub 리포지토리 \> Settings \> Pages로 이동합니다.
2.  Source를 "Deploy from a branch"로 선택합니다.
3.  Branch를 `gh-pages`로 선택하고 Save를 누릅니다.
4.  1-2분 후 배포가 완료되면 `https://username.github.io/repo-name/` 주소로 앱에 접속할 수 있습니다.

-----

## 12-3 동적 배포 Vercel

### 1\. 오프닝

정적 배포는 빠르고 무료지만 API Route를 쓸 수 없는 한계가 있었습니다. 이제 우리 앱의 모든 기능(SSR, API Routes)을 지원하는 **동적 배포**를 알아봅니다.

첫 번째 플랫폼은 **Vercel**입니다. Vercel은 Next.js를 만든 회사로, 프론트엔드 개발자들을 위한 클라우드 플랫폼을 제공합니다. 복잡한 서버 설정 없이 GitHub 저장소를 연결하기만 하면 빌드, 배포, 호스팅이 자동으로 이루어지는 'Zero Config(무설정)' 철학으로 유명합니다. 전 세계에 분산된 엣지 네트워크를 통해 매우 빠른 속도를 제공하며, 특히 Next.js 프로젝트 배포에 가장 최적화된 환경을 지원합니다

-----

### 2\. Vercel 배포 절차

Vercel 배포는 GitHub Pages와 달리 설정할 것이 거의 없습니다.

#### ▶️ **Step 1: 설정 원복 (가장 중요\!)**

  * `next.config.ts`: `basePath`와 `assetPrefix`를 **반드시 제거**해야 합니다. Vercel은 루트(`/`)에 배포됩니다. (우리 코드는 `isStaticExport` 변수로 자동 처리됩니다.)
  * `src/app/api/likes/route.ts`: `export const dynamic = 'force-dynamic';`로 **반드시 원복**해야 API가 서버에서 작동합니다.

#### ▶️ **Step 2: 배포 절차 (GitHub 연동)**

1.  Vercel.com에 GitHub 계정으로 로그인합니다.
2.  "New Project"를 클릭하고 배포할 GitHub 리포지토리(`next-ts-hands-on`)를 Import 합니다.
3.  Vercel이 자동으로 Next.js 프로젝트임을 감지합니다.
4.  **환경 변수(`STATIC_EXPORT`)를 절대 설정하지 않습니다.** (동적 모드가 기본값)
5.  "Deploy" 버튼을 클릭합니다.
6.  몇 분 안에 빌드 및 배포가 완료되고 `https://project-name.vercel.app` 형태의 URL이 생성됩니다.

#### ▶️ **(옵션) Step 2-1: Vercel CLI로 배포하기**

GitHub 연동 없이, 터미널(CLI)에서 직접 배포할 수도 있습니다.

1.  **Vercel CLI 설치:**
    ```bash
    npm install -g vercel
    ```
2.  **Vercel 로그인:**
    ```bash
    vercel login
    ```
    (브라우저가 열리며 로그인을 요청합니다.)
3.  **프로젝트 연결 (최초 1회):**
      * 로컬 프로젝트 폴더(`next-ts-hands-on`)로 이동합니다.
      * ```bash
          vercel link
        ```
      * Vercel 대시보드에 새 프로젝트를 만들거나 기존 프로젝트에 연결합니다.
4.  **배포하기:**
      * **[개발/미리보기 배포]**
        ```bash
        vercel
        ```
        (고유한 미리보기 URL이 생성됩니다.)
      * **[프로덕션(실서버) 배포]**
        ```bash
        vercel --prod
        ```
        (메인 도메인으로 배포됩니다.)
#### ▶️ **Step 3: ⚠️ 중대한 문제 발견: "상태 비저장(Stateless)"**

배포된 Vercel 앱에서 '좋아요' 버튼을 누르면 숫자가 올라가지만, **새로고침하거나 잠시 후 다시 접속하면 숫자가 0으로 초기화**되거나 랜덤하게 바뀝니다.

  * **원인:** 
      * 로컬(`npm run dev`)에서는 단 하나의 Node.js 서버가 실행되므로 `likesStore`라는 `Map` 변수가 계속 유지됩니다.
      * 하지만 Vercel 같은 서버리스(Serverless) 환경은 요청이 올 때마다 \*\*새로운 임시 컨테이너(서버)\*\*를 실행할 수 있습니다.
      * **[시나리오]**
        1.  **요청 1:** 컨테이너 A가 실행됨. `likesStore = new Map()` (빈 맵). 좋아요 +1. (맵: `{'1': 1}`)
        2.  **요청 2 (잠시 후):** 컨테이너 B (새것\!)가 실행됨. `likesStore = new Map()` (또 빈 맵). 좋아요 조회. (결과: 0)
      * 이처럼 서버리스 함수는 **"상태 비저장(Stateless)"** 특성을 갖기 때문에, `route.ts` 파일의 전역 변수(`likesStore`)에 데이터를 저장하면 안 됩니다.

#### ▶️ **Step 4: 해결책 (External Database)**

  * 모든 서버리스 인스턴스가 공유할 수 있는 **외부 데이터베이스**에 상태를 저장해야 합니다.
  * **해결책:** 11차시에서 배운 **Supabase**를 사용하거나 Vercel이 제공하는 **Vercel KV**, **Vercel Postgres**를 사용해야 합니다.

#### ▶️ **Step 5: 커스텀 도메인 연결 (Vercel)**

내 `vercel.app` 주소 대신 `mydomain.com` 같은 개인 도메인을 연결합니다.

1.  (사전 작업) Vercel , Domains 메뉴에서 Buy를 통해 도메인을 미리 구매합니다.
2.  Vercel 대시보드 \> 프로젝트 선택 \> Home에서  **Domains** 메뉴로 이동합니다.
3.  Add Domain 이후 서브 도메인 + 구입한 도메인 값을 직접 입력해줌 (ex. next.elanvital.dev )
4.  그럼 모든 설정이 한번에 끝남

-----

## 12-4 동적 배포 AWS Amplify

### 1\. 오프닝

Vercel이 Next.js 배포에 가장 쉬운 방법이었다면, 이번에는 세계 1위 클라우드 플랫폼인 AWS를 활용한 배포를 알아보겠습니다.

먼저 **AWS(Amazon Web Services)**는 전 세계에서 가장 널리 사용되는 클라우드 컴퓨팅 플랫폼입니다. 가상 서버(EC2), 데이터베이스(RDS), 스토리지(S3) 등 수백 가지의 서비스를 '레고 블록'처럼 조합하여 상상할 수 있는 거의 모든 IT 인프라를 구축할 수 있습니다. Vercel이 프론트엔드 배포에 특화되었다면, AWS는 IT 인프라 전체를 다루는 훨씬 더 광범위하고 강력한 서비스입니다.

하지만 AWS는 기능이 너무 방대해서 프론트엔드 앱 하나를 배포하는 것도 복잡할 수 있는데, **AWS Amplify**는 바로 이 문제를 해결해 줍니다. Amplify는 Vercel처럼 쉽고 빠른 웹/모바일 앱 배포(CI/CD)에 중점을 둔 AWS의 관리형 서비스입니다. 클릭 몇 번으로 GitHub 저장소를 연결하면 빌드, 배포, 호스팅은 물론, AWS의 강력한 백엔드 서비스(인증, DB, API 등)와 손쉽게 통합할 수 있게 도와줍니다.

-----

### 2\. AWS Amplify 배포 절차

#### ▶️ **Step 1: AWS 계정 준비 (🔐 가장 중요\!)**

Vercel과 달리 AWS는 강력한 보안 설정을 먼저 요구합니다. 

1.  **AWS 무료 티어 계정 가입 (루트 사용자):** AWS에 가입하여 '루트 사용자' 계정을 생성합니다.
2.  **루트 사용자 MFA 설정:** 계정 탈취를 막기 위해 로그인 후 즉시 '보안 자격 증명'에서 Google Authenticator 같은 MFA(다중 인증)를 설정합니다. **(필수 보안 조치)**
3.  **IAM 사용자 생성:** 앞으로의 모든 작업은 루트 계정이 아닌, `AdministratorAccess` 권한을 가진 **IAM 사용자**를 새로 만들어서 수행해야 합니다. (예: `amplify-admin`)
4.  **IAM 사용자 MFA 설정:** 새로 만든 IAM 사용자에게도 동일하게 MFA를 설정합니다.
5.  **로그아웃 후 IAM 사용자로 로그인:** 앞으로는 항상 IAM 사용자로 로그인합니다.

#### ▶️ **Step 2: `amplify.yml` 설정 파일**

Amplify는 Vercel과 달리 `amplify.yml`이라는 설정 파일로 빌드 및 배포를 제어합니다. 이 파일은 이미 우리 리포지토리 루트에 포함되어 있습니다.

```yaml
# amplify.yml
version: 1
frontend:
  phases:
    preBuild:
      commands:
        - npm ci       # npm install 보다 빠르고 안정적인 설치
    build:
      commands:
        - npm run build  # 동적 빌드 실행
  artifacts:
    baseDirectory: .next   # Next.js 13+ 의 빌드 결과물
    files:
      - '**/*'
  cache:
    paths:
      - node_modules/**/*
      - .next/cache/**/* # 빌드 캐시로 속도 향상
```

#### ▶️ **Step 3: Amplify 콘솔에서 배포**

1.  AWS Amplify Console에 (IAM 사용자로) 로그인합니다.
2.  "New app" \> "Host web app"을 선택합니다.
3.  GitHub를 선택하고 리포지토리(`next-ts-hands-on`)와 `main` 브랜치를 연결합니다.
4.  Amplify가 `amplify.yml` 파일을 자동으로 감지하고 빌드 설정을 보여줍니다.
5.  "Save and deploy"를 클릭합니다.

#### ▶️ **Step 4: 커스텀 도메인 연결 (Amplify)**

Amplify는 AWS의 도메인 서비스인 **Route 53**과 완벽하게 연동됩니다.

1.  (사전 작업) AWS **Route 53** 서비스에서 미리 도메인을 구매(또는 이전)합니다.
2.  Amplify 콘솔 \> App settings \> **Domain management**로 이동합니다.
3.  \*\*"Add domain"\*\*을 클릭하고 Route 53에서 관리 중인 도메인을 선택합니다.
4.  하위 도메인(e.g., `www`)과 루트 도메인 리디렉션을 설정하고 저장합니다.
5.  Route 53을 사용하면 Amplify가 **DNS 레코드와 SSL 인증서를 모두 자동으로 설정**해 주므로 매우 편리합니다.

---

## 맺음말: 나에게 맞는 배포 플랫폼 선택하기 🚀

12차시에서는 정적 배포(GitHub Pages)부터 동적 배포(Vercel, AWS Amplify)까지 다양한 플랫폼을 경험했습니다. 이제 여러분의 상황에 맞는 최적의 플랫폼을 선택할 수 있는 기준을 정리해 드립니다.

### 1. "빠른 MVP와 프론트엔드"가 중요하다면: Vercel

Vercel은 Next.js를 만든 회사가 제공하는 플랫폼답게 Next.js 배포에 가장 최적화되어 있습니다.

* **추천 대상:**
    * **초급자** 또는 **1인 개발자**
    * **빠른 MVP(Minimum Viable Product)** 제작이 목표인 경우
    * 프로젝트가 복잡한 백엔드 로직보다는 **프론트엔드 경험**에 집중되어 있을 때
* **핵심 이유:**
    * **Zero-Config:** GitHub 리포지토리 연결만 하면 빌드, 배포, CDN 설정이 자동으로 완료됩니다.
    * **압도적인 편의성:** 위에서 경험했듯이, 도메인을 Vercel에서 직접 구매하고 연결하는 과정이 매우 간단합니다.

### 2. "백엔드 통합과 확장성"이 중요하다면: AWS Amplify / GCP

AWS와 GCP는 Vercel처럼 편리한 배포(CI/CD) 기능을 제공하면서, 동시에 강력한 클라우드 생태계 전체와 유기적으로 연동됩니다.

* **추천 대상:**
    * **중급자 이상** 또는 **팀 단위 개발**
    * 13차시에서 배울 **S3, Cloud Run(GCP), Lambda(AWS)** 등 다른 클라우드 서비스와 **네트워킹/보안** 연계가 필수적인 경우
    * 이미 팀(회사)에서 AWS 또는 GCP를 메인 클라우드로 사용하고 있을 때
* **핵심 이유:**
    * **통합 관리:** 프론트엔드 배포(Amplify)와 백엔드 서비스(S3, DB 등)를 한곳에서 통합 관리(IAM, 빌링, 로깅)할 수 있습니다.
    * **생태계:** AWS Amplify는 12-4에서처럼 AWS Route 53(도메인)과 완벽하게 자동 연동되는 등, 자사 생태계 내에서 강력한 시너지를 냅니다.

### 💡 전문가 팁: 도메인과 배포를 분리해서 생각하라

초보자들은 'Vercel에서 배포하면 도메인도 Vercel에서 사야 한다'고 생각하기 쉽지만, 그렇지 않습니다. **배포 플랫폼(Host)과 도메인 관리(DNS)는 완전히 분리할 수 있습니다.**

> **"도메인 서비스 발급 및 운영을 자유롭게 할 수 있으면 어떤 플랫폼이든 상관없다"**
>
> **가장 유연하고 전문적인 방법**은 AWS Route 53, Cloudflare, Google Domains 같은 전문 DNS 서비스에서 도메인을 구매하고 관리하는 것입니다.
>
> 그런 다음, DNS 설정(CNAME, A 레코드)만 변경하여 **오늘은 Vercel로**, **내일은 AWS Amplify로**, **다음 프로젝트는 GCP Cloud Run**으로 자유롭게 트래픽을 연결(Pointing)할 수 있습니다.
>
> **결론:**
>
> * **DNS가 어렵고 귀찮다면:** Vercel처럼 도메인 구매부터 배포까지 **All-in-One**으로 해결되는 플랫폼을 선택하세요.
> * **DNS를 직접 제어할 수 있다면:** 플랫폼에 종속되지 않습니다. 도메인은 전문 서비스에 맡기고, 프로젝트의 성격에 따라 가장 유리한 배포 플랫폼(Vercel의 속도, AWS의 통합 등)을 자유롭게 선택하세요.