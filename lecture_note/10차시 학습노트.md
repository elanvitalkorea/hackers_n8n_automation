## 10-1. AI Simple Agent 및 텔레그램 연동 💬

### 1. AI Agent의 4가지 핵심 요소
AI Agent는 다음 요소들을 통합하여 자율적인 의사결정 및 행동을 수행합니다:
* **LLM (Large Language Model)**
* **Autonomy (자율성)**
* **Memory (기억)**
* **Tool (도구)**
![[Pasted image 20251019114207.png]]

### 2. 텔레그램 기반 AI Agent 구축
* **Chat Trigger**: n8n 내부 채팅 또는 `production url`을 통해 외부에서 챗봇을 시작할 수 있으며, 인사말(greetings), 플레이스 홀더(place holder), 스타일 커스텀이 가능합니다.
* **유머 생성기 Agent**:
    * **메모리(Memory) 기능**: Agent가 이전 대화 내용을 기억하도록 설정합니다.
        * **Basic Memory**: 인스턴스가 꺼지면 대화 기록이 사라지므로, 영구 저장을 위해 **Supabase** 등에 저장해야 합니다.
        * **Session Key**를 설정하여 특정 대화 세션을 구분합니다.
    * **Instruction**: Agent의 역할(예: 세상에서 가장 웃긴 개그맨)을 정의하는 기본 지식을 설명합니다.
    * **n8n 디버깅 영역**: n8n 하단에서 **AI Agent의 연쇄적인 호출 현황**을 GUI로 시각적으로 확인할 수 있습니다.
* **텔레그램 연동 과정**:
    1.  **텔레그램 설치** 및 **BotFather**를 통해 봇 생성 후 **AccessToken** 발급.
    2.  n8n에 **Credential** 및 **텔레그램 Trigger** 설정.
    3.  수신된 메시지가 **text**인지 **voice**인지에 따라 워크플로우를 분기 처리 (`Switch` 노드 활용).
    4.  **Elevenlabs** 또는 **ChatGPT/Gemini** 모델을 활용하여 음성-텍스트 변환(**STT**) 및 텍스트-음성 변환(**TTS**)을 구현합니다.

---

## 10-2. Voice AI Agent 및 Elevenlabs 연동 🎤

### 1. Calendar Agent (Tool의 첫 구현)
* **Tool 개념 구현**: Google Calendar 기능을 활용하는 Agent를 생성하며, **Tool**로서 `create event`, `search event`, `delete event` 기능을 처음 구현합니다.
* **Webhook Trigger**:
    * Elevenlabs Voice Agent와 n8n을 연결하는 핵심 트리거입니다.
    * 외부에서 API 호출을 트리거할 수 있으며, `get` 또는 `post` 방식이 가능하고, 호출에 대한 `response`를 돌려줄 수 있어 외부 세계와의 연결점 역할을 합니다.

### 2. Elevenlabs Conversational Agent 설정
Elevenlabs에서 대화형 Agent를 생성하고 n8n의 Calendar Agent와 연동합니다:
* **Agent 설정**: New Agent → Blank Agent 선택, Language를 **Korean**으로 설정.
* **System Prompt**: Agent 역할 정의(예: 개인 비서, 일정 관리)와 함께, **Tool**의 이름(`n8n_agent`)을 마지막에 기술하여 n8n 웹훅과 연결됨을 명시해야 합니다.
* **Tool 설정**:
    * **Description**: "Please call this tool when managing the calendar."와 같이 Tool 사용 시점을 명확히 기술합니다.
    * **Method**: Post.
    * **URL**: 개발용 웹훅 URL 연결.
    * **Response Timeout**: 최대 120초로 길게 설정.
    * **Body Parameters**: `query` 속성(필수)에 **스케줄 관리 요청의 원본 텍스트**를 그대로 전달하도록 정의합니다.
        * ``Query to pass the original text of the schedule management request as-is``

### 3. n8n Calendar Agent 수정
Elevenlabs의 요청을 처리하고 응답을 돌려주는 n8n 워크플로우를 구성합니다:
* **Agent Prompt**:
    * `type`: define below.
    * `text`: `{{ $json.body.query }}` (Elevenlabs가 전달한 쿼리 사용).
* **Memory Session ID**:
    * `type`: define below.
    * `sessionKey`: `{{ $json.webhookUrl.split('/').pop() }}`와 같이 웹훅 URL의 고유 부분(ID)을 추출하여 **일관된 세션 값**으로 설정합니다.
* **응답**: 워크플로우 마지막에 **'Respond Webhook' Node**를 사용하여 Elevenlabs로 응답을 돌려주면 **완전한 실시간 보이스 인터랙션**이 가능합니다.

#### Voice 프롬프트 보강 예시 (출력 형식 통제)
응답을 음성 모델이 문제없이 발화하도록 출력 형식을 통제합니다:
* **Role**: 일정 관리 비서 역할.
* **출력 형식**: 구어체로 변환, 특수기호 적절한 의미로 치환, 줄바꿈 문자(`\n`) 제거.
* **Tool 목록**: Agent가 사용할 Tool의 이름과 용도를 명시.
```
## Role
너는 일정 관리 비서야. 일정 생성 / 일정 여러개 조회/ 일정 삭제가 가능해 

## 출력형식
- 구어체 즉 Voice Model이 문제 없도록 시간 형식으로 모두 바꿔주세요 
- 시간 출력 형식
	- 특수기호는 모두 적당한 의미로 치환해주세요 
	- 17:30~19:30 -> 17시30분 부터 2시간 
	- `\n` 이런 줄바꿈 문자는 모두 없애주세요 

## Tool
**Calander Management Tools**
- "create_event" : 일정을 만들 때 사용
- "get_many_events" : 일정을 여러개 조회 시 사용
- "delete_event" : 일정삭제 시 사용 

today's date is {{ $now }}
```

---

## 10-3. SubAgent 계층 구조 생성 🏗️

복합적인 요청을 처리하기 위해 주 Agent(Classifier)와 전문 Agent(SubAgent)로 구성된 계층적 구조를 만듭니다.

### 1. Agent 구성 및 SubAgent 설정
* **Agent 구조**: Simple 1 Agent, 혹은 **SubAgent 계층**으로 구성될 수 있습니다.
* **SubAgent 생성**: **Call workflow** 노드를 사용하여 다른 워크플로우를 SubAgent로 설정할 수 있습니다.
    * 예: **Gmail Creator Agent**를 생성하고 `send mail`과 `make draft` 두 가지 Tool을 등록합니다.
    * **Calendar Agent로 분기**: 10-2에서 만든 Calendar Agent로 요청을 분기하여 호출합니다.
* **Calling 간 인터페이스**: 워크플로우 간 호출 시 필요한 입력 변수(예: `userQuery`, `jobDescription`, `sessionId`)를 정의하고 전달합니다.

### 2. Dispatcher-Agent 모델 (JSON Output Parser)
* **JSON Output Parser**: Agent가 언어 대신 **JSON 형태의 구조화된 출력**을 생성하도록 강제합니다 (실습은 진행하지 않음).
* **활용**:
    * **분류기(Classifier)로 사용**: JSON 결과를 바탕으로 **Switch Node**를 이용하여 요청을 여러 Specialist Agent로 분기 처리하는 **Dispatcher-Agent 모델**에 사용됩니다.

---

네, RAG에 대한 설명을 추가하여 학습 노트를 업데이트했습니다.

## 10-4. RAG Agent 및 Supabase Vectorstore 연동 📖

**RAG(Retrieval-Augmented Generation)**란 '검색 증강 생성'을 의미합니다. RAG는 대규모 언어 모델(LLM)이 답변을 생성할 때, **최신 정보나 특정 도메인의 전문 지식이 담긴 외부 데이터베이스(Vector Store 등)에서 관련 정보를 먼저 검색(Retrieval)**하도록 하는 기술입니다.

검색된 정보를 바탕으로 LLM이 답변을 **생성(Generation)**하기 때문에, 모델이 학습하지 않은 최신 정보나 내부 문서에 대해서도 정확하고 근거 있는 답변을 제공할 수 있습니다. (예: 환각 현상 감소)


![[Pasted image 20251021113127.png]]

외부 문서(PDF)를 검색하여 답변의 근거로 활용하는 RAG(검색 증강 생성) 시스템을 구축합니다.

### 1. Vector 데이터 저장 워크플로우
* **소스 데이터**: Google Drive에 업로드된 테슬라 매뉴얼 PDF 등을 활용합니다.
* **Embedding**: **OpenAI Embedding**을 사용하여 문서를 벡터화합니다.
    * `dimensions size`는 **1536**으로 설정하여 Supabase document 테이블과 일치시킵니다.
* **Default Data Loader**:
    * `Text splitter`: **Custom** 선택.
    * **Recursive Character Text Splitter**: 문맥을 가장 잘 보존하며 텍스트를 효율적으로 분할하는 데 가장 많이 사용됩니다.
    * **Chunk Overlap**: **200**과 같이 적절한 크기를 설정하여 문맥 보존을 돕습니다.
* **Vector Store 선택**:
    * **Simple Vector Store**: 인스턴스 재부팅 시 데이터가 사라집니다.
    * **Supabase Vector Store**: **Langchain Template**으로 `document` 테이블을 생성하고, Simple Vector Store 대신 사용하여 영구적인 벡터 데이터 저장을 구현합니다.

### 2. RAG Agent 구현
* **AI Agent에 Tool 등록**: 구축한 **Supabase Vector Store**를 Agent의 Tool 목록에 추가합니다 (Tool 이름: `Vectore Store`).
* **Agent Prompt**: Agent의 시스템 메시지에 `Vectore Store`를 포함하여, 테슬라 관련 매뉴얼 검색 시 해당 Tool을 사용하도록 지시합니다.
    * Agent는 사용자의 질의에 따라 `Gmail Agent`, `Galendar Agent` 또는 `Vectore Store` 중 적절한 Tool을 선택하게 됩니다.
