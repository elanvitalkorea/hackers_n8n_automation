    
## 🚀 5-1. 인증(Authentication) 시스템 이해

지난 시간에는 누구나 요청하면 데이터를 주던 간단한 API 서버를 만들었습니다. 하지만 실제 서비스에서는 '누가' 요청했는지 확인하고, '허가된 사람'에게만 데이터를 보여주는 과정이 필수적입니다. 이것이 바로 **인증(Authentication)** 입니다.

### 인증은 왜 필요할까요? 🏨

인증을 가장 쉽게 이해할 수 있는 비유는 **호텔과 멤버십**입니다.

- **호텔 예약 및 체크인 (멤버십 가입 및 로그인)**: 호텔에 묵으려면 먼저 돈을 지불하고(서비스 가입) 예약을 한 뒤, 체크인 카운터에서 신분증을 보여주고 본인임을 증명해야 합니다. 이 과정이 웹 서비스의 **회원가입**과 **로그인**입니다.
    
- **호텔 카드키 발급 (인증 토큰 발급)**: 체크인이 완료되면, 프론트 데스크에서 내 방에만 들어갈 수 있는 '카드키'를 줍니다. 이 카드키가 바로 서버가 사용자를 확인하고 발급해주는 **인증 토큰(Access Token)**입니다. 이 키가 없으면 엘리베이터를 타거나 방에 들어갈 수 없습니다.
    
- **카드키 사용 (API 요청)**: 방에 들어가거나, 수영장, 피트니스 센터 같은 부대시설을 이용할 때마다 카드키를 찍어야 합니다. 이것은 보호된 API에 접근할 때마다 발급받은 토큰을 함께 보내 '나'라는 것을 증명하는 과정과 같습니다. 카드키(토큰)가 없으면 서비스(방, 시설)를 이용할 수 없습니다.
    

결국 인증은 우리 서비스의 자원을 보호하고, 사용자별로 맞춤형 경험을 제공하기 위한 첫 번째 관문입니다.


![hackers_5th_01](https://hackers-n8n-lecture.s3.ap-northeast-2.amazonaws.com/images/hackers_5th_01.png)

### 인증 vs 인가 (Authentication vs Authorization)

|구분|인증 (Authentication)|인가 (Authorization)|
|---|---|---|
|**질문**|"너는 누구야?"|"너는 이걸 할 수 있어?"|
|**호텔 예시**|카드키로 투숙객임을 확인|스위트룸 투숙객만 라운지 이용 가능|
|**멤버십 예시**|멤버십 카드로 회원임을 확인|VIP 회원만 무료 배송 혜택|
|**웹 서비스**|로그인 토큰 검증|관리자만 사용자 삭제 가능|


### 인증 방식의 종류

1. **세션/쿠키 방식**: 전통적인 방식으로, 서버가 사용자의 로그인 정보를 서버 메모리나 DB에 '세션'으로 저장하고, 브라우저에는 '세션 ID'가 담긴 쿠키를 보냅니다. 사용자는 요청마다 이 쿠키를 보내고, 서버는 세션 ID를 보고 사용자를 식별합니다. 여전히 많이 쓰이며, 장바구니 처럼 사용자의 상태를 계속 기억을 할 때 쓰임.  
    
2. **토큰 기반 방식 (JWT)**: 현대적인 API 서버에서 주로 사용하는 방식입니다. 서버는 사용자의 정보를 암호화한 '토큰'을 발급하고, 사용자는 이 토큰을 요청 헤더에 담아 보냅니다. 서버는 토큰의 유효성만 검증하면 되므로, 사용자 상태를 따로 저장할 필요가 없어(Stateless) 확장성이 뛰어납니다. n8n 같은 자동화 툴이나 모바일 앱 연동에 필수적입니다.
    

---

## 🔐 5-2. JWT(JSON Web Token) 기반 인증 구현

4차시에서 만든 `todo-api`에 JWT를 이용한 인증 기능을 추가해 보겠습니다. 이제 할 일(Todo)은 아무나 등록하고 보는 것이 아니라, 로그인한 사용자만 자신의 할 일을 관리할 수 있게 됩니다.

### JWT란?

**JSON Web Token**의 약자로, 이름 그대로 JSON 객체를 웹 환경에서 안전하게 전송하기 위한 표준 규격입니다. 토큰 자체가 암호화된 사용자 정보를 담고 있어 매우 효율적입니다.

**구조**: `xxxxx.yyyyy.zzzzz` 형태이며, 각 부분은 점(`.`)으로 구분됩니다.

    
```http
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### JWT (JSON Web Token) 이해

#### JWT 구조 분석

![hackers_5th_02](https://hackers-n8n-lecture.s3.ap-northeast-2.amazonaws.com/images/hackers_5th_02.png)

#### JWT 구성 요소

**1. Header (헤더)**

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**2. Payload (페이로드)**

```json
{
  "sub": "1234567890",
  "name": "김철수", 
  "email": "kim@example.com",
  "iat": 1516239022,
  "exp": 1516242622
}
```

**3. Signature (서명)**

```javascript
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```


> 🔍 온라인 JWT 디코더
> 
> 발급된 JWT가 어떤 정보를 담고 있는지 궁금하다면 [jwt.io](https://www.jwt.io/) 사이트에서 쉽게 확인할 수 있습니다. 토큰을 붙여넣으면 Header, Payload 내용을 바로 볼 수 있어 디버깅에 매우 유용합니다.

### Todo API에 JWT 인증 적용하기

#### 1. 프로젝트 설정 및 라이브러리 설치

Bash

```bash
# 4차시 todo-api 프로젝트 폴더로 이동
cd todo-api
# jsonwebtoken 라이브러리 설치
npm install jsonwebtoken
```

#### 2. 사용자 정보 관리 (간단한 메모리 DB)

실제로는 DB에 저장해야 하지만, 여기서는 간단하게 배열로 사용자를 관리하겠습니다.

JavaScript

```js
// app.js 상단에 추가
const users = []; // {id, password} 저장
let userIdCounter = 1;
```

#### 3. 회원가입 및 로그인 엔드포인트 구현

JavaScript

```js
// app.js
const jwt = require('jsonwebtoken');
const SECRET_KEY = 'YOUR_SUPER_SECRET_KEY'; // 실제 프로젝트에서는 환경 변수로 관리해야 합니다.

// ... (기존 코드)

// 회원가입
app.post('/api/auth/register', (req, res) => {
    const { id, password } = req.body;
    if (!id || !password) {
        return res.status(400).json({ error: 'ID와 비밀번호를 모두 입력하세요.' });
    }
    if (users.find(u => u.id === id)) {
        return res.status(409).json({ error: '이미 존재하는 ID입니다.' });
    }
    users.push({ id, password });
    res.status(201).json({ message: '회원가입 성공!' });
});

// 로그인
app.post('/api/auth/login', (req, res) => {
    const { id, password } = req.body;
    const user = users.find(u => u.id === id && u.password === password);
    if (!user) {
        return res.status(401).json({ error: '인증 실패' });
    }

    // JWT 토큰 생성
    const token = jwt.sign(
        { userId: user.id }, // Payload에 담을 정보
        SECRET_KEY,          // 비밀 키
        { expiresIn: '1h' }   // 유효 시간 (1시간)
    );

    res.json({ accessToken: token });
});
```

#### 4. 인증 미들웨어 구현

API 요청이 들어왔을 때, 헤더에 담긴 토큰을 검증하는 '미들웨어'를 만듭니다. 미들웨어는 모든 요청 처리 과정의 중간에서 특정 역할을 수행하는 함수입니다.

JavaScript

```js
// app.js 에 추가
function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // "Bearer TOKEN" 형식

    if (token == null) return res.sendStatus(401); // 토큰 없음

    jwt.verify(token, SECRET_KEY, (err, user) => {
        if (err) return res.sendStatus(403); // 토큰 유효하지 않음
        req.user = user; // 요청 객체에 사용자 정보 저장
        next(); // 다음 미들웨어 또는 라우터로 이동
    });
}
```

#### 5. 기존 CRUD에 미들웨어 적용

이제 `authenticateToken` 미들웨어를 할 일(Todo) 관련 API에 적용하여, 로그인한 사용자만 접근할 수 있도록 보호합니다.

JavaScript

```js
// app.js의 CRUD 엔드포인트 수정

// 모든 할 일 조회 (보호된 라우트)
app.get('/api/todos', authenticateToken, (req, res) => {
    // 이제 req.user.userId 로 어떤 사용자인지 알 수 있습니다.
    // 여기서는 일단 모든 todos를 반환하지만, 추후 DB와 연동하여
    // 해당 유저의 todos만 반환하도록 수정할 것입니다.
    const todos = readTodos();
    res.json(todos);
});

// 새로운 할 일 추가 (보호된 라우트)
app.post('/api/todos', authenticateToken, (req, res) => {
    // ... 기존 로직 ...
    const newTodo = {
        id: Date.now(),
        title: req.body.title,
        completed: false,
        owner: req.user.userId, // 할 일의 소유자 정보 추가
        createdAt: new Date().toISOString()
    };
    // ...
});

// PUT, DELETE도 동일하게 authenticateToken 미들웨어를 추가합니다.
app.put('/api/todos/:id', authenticateToken, (req, res) => { /* ... */ });
app.delete('/api/todos/:id', authenticateToken, (req, res) => { /* ... */ });
```

이제 `/api/todos`에 접근하려면 반드시 HTTP 요청 헤더에 `Authorization: Bearer <발급받은_토큰>` 을 포함해야 합니다.

#### 6. Rest Client 통한 테스트

```http
### 회원가입
POST http://localhost:3000/api/auth/register
Content-Type: application/json

{
    "id": "testuser",
    "password": "testpass123"
}

###

### 로그인
POST http://localhost:3000/api/auth/login
Content-Type: application/json

{
    "id": "testuser",
    "password": "testpass123"
}

###

@authToken = xxx.yyy.zzz

### 인증이 필요한 모든 할 일 조회
GET http://localhost:3000/api/todos
# Authorization: Bearer {{authToken}}

### 인증이 필요한 할 일 생성 (JWT 토큰 수동 사용)
POST http://localhost:3000/api/todos
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "title": "인증된 사용자의 할 일"
}

```

---


## 🔑 5-3. 구글 인증 이해

### OAuth 2.0 이해

**OAuth란?**: 제3자 애플리케이션이 사용자 대신 서비스에 접근할 수 있도록 권한을 부여하는 개방형 표준

#### OAuth 흐름 (Authorization Code Flow)

```
1. [사용자] → [우리 앱]: "구글로 로그인" 버튼 클릭

2. [우리 앱] → [구글]: 사용자를 구글 로그인 페이지로 리디렉션
   https://accounts.google.com/oauth/authorize?
   client_id=YOUR_CLIENT_ID&
   redirect_uri=YOUR_CALLBACK_URL&
   scope=email+profile&
   response_type=code

3. [사용자] → [구글]: 구글 계정으로 로그인 + 권한 승인

4. [구글] → [우리 앱]: 인증 코드(authorization code)와 함께 콜백 URL로 리디렉션

5. [우리 앱] → [구글]: 인증 코드를 액세스 토큰으로 교환

6. [우리 앱] → [구글]: 액세스 토큰으로 사용자 정보 요청

7. [구글] → [우리 앱]: 사용자 프로필 정보 응답

8. [우리 앱]: 사용자 정보로 JWT 토큰 생성 및 로그인 처리
```


![hackers_5th_03](https://hackers-n8n-lecture.s3.ap-northeast-2.amazonaws.com/images/hackers_5th_03.png)

### 소셜 로그인의 장점
#### 1. **사용자 경험 개선**
- 빠른 가입/로그인 과정
- 비밀번호 기억 부담 없음
- 신뢰할 수 있는 서비스 활용
#### 2. **개발 비용 절감**
- 사용자 인증 로직 간소화
- 이메일 인증, 비밀번호 재설정 등 부가 기능 불필요
- 보안 책임 분산
#### 3. **사용자 정보 활용**
- 검증된 이메일 주소 확보
- 기본 프로필 정보 즉시 이용 가능
- 추가 API 활용 가능 (Google Drive, Calendar 등)

##### 참고 - 구글에서 받는 프로필 정보
```json
{
  "id": "109876543210987654321",
  "email": "user.name@gmail.com",
  "verified_email": true,
  "name": "홍길동",
  "given_name": "길동",
  "family_name": "홍",
  "picture": "https://lh3.googleusercontent.com/a-/AOh14_.../photo.jpg"
}
```

### Google OAuth 설정

#### 1. Google Cloud Console 설정

1. **Google Cloud Console** 접속: https://console.cloud.google.com/
2. **새 프로젝트 생성** 또는 기존 프로젝트 선택
3. **API 및 서비스 > 사용자 인증 정보** 메뉴
4. **OAuth 2.0 클라이언트 ID 생성**:
    - 애플리케이션 유형: 웹 애플리케이션
    - 승인된 리디렉션 URI: `http://localhost:3000/api/auth/google/callback`

#### 2. 환경 변수 설정
```javascript
// .env 파일 생성
GOOGLE_CLIENT_ID=your_google_client_id.googleusercontent.com
GOOGLE_CLIENT_SECRET=your_google_client_secret
```

#### 3. Google OAuth 구현
```bash
npm install passport passport-google-oauth20 express-session
```

```javascript
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const session = require('express-session');

// 세션 설정
app.use(session({
    secret: 'your-session-secret',
    resave: false,
    saveUninitialized: false
}));

app.use(passport.initialize());
app.use(passport.session());

// Google OAuth Strategy 설정
passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: "/api/auth/google/callback"
}, async (accessToken, refreshToken, profile, done) => {
    try {
        const users = readUsers();
        let user = users.find(u => u.googleId === profile.id);

        if (!user) {
            // 새 사용자 생성
            user = {
                id: Date.now(),
                googleId: profile.id,
                email: profile.emails[0].value,
                name: profile.displayName,
                avatar: profile.photos[0].value,
                createdAt: new Date().toISOString()
            };
            users.push(user);
            writeUsers(users);
        }

        return done(null, user);
    } catch (error) {
        return done(error, null);
    }
}));

passport.serializeUser((user, done) => {
    done(null, user.id);
});

passport.deserializeUser((id, done) => {
    const users = readUsers();
    const user = users.find(u => u.id === id);
    done(null, user);
});

// Google OAuth 라우트
app.get('/api/auth/google',
    passport.authenticate('google', { scope: ['profile', 'email'] })
);

app.get('/api/auth/google/callback',
    passport.authenticate('google', { failureRedirect: '/login' }),
    (req, res) => {
        // 성공적인 인증 후 JWT 토큰 생성
        const token = generateToken(req.user);
        
        // 프론트엔드로 토큰 전달 (실제로는 secure한 방법 사용)
        res.redirect(`http://localhost:3001/auth-success?token=${token}`);
    }
);
```


### 실제 구현 트렌드 
- 실제로는 FrontEnd 에서 supabase나 firebase의 social 로그인을 이용해서 쉽게 처리
- 인증은 supabase에 맡기고 복잡한 backend 로직은 별도로 만들고 supabase 발생 토큰 검사 수행
- 개발 단계이거나 용량이 매우 크지 않다면 supabase내 edge function으로 그것도 커버 가능함


--- 

## ⚡ 5-4. Supabase 소개 및 DB 구현

### Supabase란?

**정의**: **PostgreSQL** 데이터베이스를 중심으로 **인증, 스토리지, 자동 생성 API** 등 강력한 백엔드 기능을 통합 제공하는 **오픈소스 BaaS 플랫폼**입니다. 💻

기존의 복잡한 서버 개발 및 인프라 관리 없이, PostgreSQL의 모든 기능을 활용하며 빠르고 확장 가능한 애플리케이션을 구축할 수 있습니다.

> [!NOTE] BaaS 란
> **BaaS(Backend as a Service)**는 데이터베이스, 인증, 스토리지 등 백엔드 개발에 필요한 기능들을 API 형태로 제공하는 클라우드 서비스입니다. 우리는 복잡한 서버 인프라 구축 없이, 제공되는 API만 호출하여 강력한 백엔드 기능을 구현할 수 있습니다.

### Supabase의 핵심 특징 ✨

Supabase는 단순한 데이터 저장을 넘어, PostgreSQL이라는 검증된 기술을 기반으로 개발자에게 높은 자유도와 강력한 기능을 제공합니다.

* **PostgreSQL의 모든 기능 활용**: Supabase의 핵심입니다. 모든 프로젝트는 **전용 PostgreSQL 데이터베이스**를 기반으로 하며, 다음과 같은 장점을 가집니다.
    * **관계형 데이터 모델**: 정교하고 안정적인 데이터 구조 설계가 가능합니다.
    * **SQL 완전 지원**: 단순한 CRUD를 넘어 복잡한 `JOIN`, `VIEW`, `Stored Procedure` 등 모든 SQL 기능을 사용할 수 있어 데이터 활용도를 극대화합니다.
    * **Row Level Security (RLS)**: 데이터베이스 레벨에서 각 행(row)에 대한 접근 권한을 정책(Policy)으로 세밀하게 제어하여 강력한 보안을 구현합니다.
    * **풍부한 확장성**: PostGIS(위치기반), TimescaleDB(시계열) 등 PostgreSQL의 다양한 확장 기능을 그대로 사용할 수 있습니다. 

* **자동 생성 API (Auto-generated APIs)**: 데이터베이스 테이블 스키마를 정의하면, 별도의 코딩 없이 즉시 사용할 수 있는 **RESTful API**와 **실시간(Realtime) API**가 자동으로 생성됩니다. 개발자는 프론트엔드에만 집중할 수 있습니다.

* **통합 인증 시스템 (Supabase Auth)**: 이메일/비밀번호 인증은 물론, Google, GitHub, Kakao 등 다양한 **소셜 로그인**, **Magic Link** 기능을 기본으로 제공합니다. RLS와 결합하여 사용자별 데이터 접근을 손쉽게 제어할 수 있습니다.

* **실시간 구독 (Realtime Subscriptions)**: 데이터베이스에 `INSERT`, `UPDATE`, `DELETE` 등의 변경이 발생하면, 이를 즉시 감지하여 클라이언트에 푸시(push)해주는 강력한 실시간 기능을 제공합니다. 채팅, 알림, 실시간 대시보드 등을 손쉽게 구현할 수 있습니다.

* **파일 스토리지 (Storage)**: 이미지, 동영상 등 대용량 파일을 저장하고 관리할 수 있는 **객체 스토리지**를 제공합니다. 권한 설정을 통해 특정 사용자만 파일에 접근하도록 제어할 수 있습니다.

* **Edge Functions: 서버리스 백엔드 로직 ⚡️**: 단순 CRUD를 넘어선 커스텀 백엔드 로직을 실행할 수 있는 **서버리스 함수**입니다. 별도의 서버를 구축하고 관리할 필요 없이 코드만 배포하면 됩니다.
    * **빠른 응답 속도**: 전 세계에 분산된 서버 네트워크(Edge Network)에서 사용자와 가장 가까운 위치에서 함수가 실행되어 매우 빠른 속도를 보장합니다.
    * **안전한 로직 실행**: 결제 처리, 외부 API 연동 등 **비밀 키나 민감한 로직**을 프론트엔드에 노출시키지 않고 서버 환경에서 안전하게 실행할 수 있습니다.
    * **유연한 활용성**: **웹훅(Webhook) 처리**, 데이터 검증 및 변환, 알림 발송 등 서비스에 필요한 다양한 맞춤형 기능을 구현할 수 있습니다.
    * **자동 확장성**: 트래픽이 급증해도 Supabase가 알아서 자원을 할당하고 확장해주므로 개발자는 인프라 걱정을 할 필요가 없습니다.

* **오픈소스 기반**: 모든 구성 요소가 오픈소스로 공개되어 있어 특정 클라우드 서비스에 종속될 우려(**Vendor Lock-in**)가 적습니다. 원한다면 직접 서버에 설치하여 운영(**Self-hosting**)할 수도 있어 유연성이 매우 높습니다.


-----

#### 🚀 자동 생성 API (Auto-generated APIs) 상세 설명

Supabase의 가장 큰 매력 중 하나는, 개발자가 데이터베이스에 **테이블을 만들기만 하면** 별도의 API 서버 코딩 없이 **즉시 데이터를 다룰 수 있는 RESTful API가 자동으로 생성**된다는 점입니다.

##### 어떻게 동작하나요?

1.  Supabase 대시보드나 SQL 쿼리를 사용해 `posts`라는 테이블을 생성합니다.
2.  Supabase는 이 테이블 구조를 즉시 분석하여 데이터를 조회(`SELECT`), 추가(`INSERT`), 수정(`UPDATE`), 삭제(`DELETE`)할 수 있는 고유한 API 엔드포인트(URL)를 자동으로 만들어줍니다.
3.  개발자는 `supabase-js`와 같은 클라이언트 라이브러리를 사용해 이 엔드포인트로 요청을 보내기만 하면 됩니다. 복잡한 서버 로직, 라우팅, 컨트롤러를 작성할 필요가 없습니다.

##### API가 실제적으로 동작하는 방식 (핵심 요약)

Supabase는 내부적으로 **PostgREST**라는 도구를 사용합니다. 이 도구는 데이터베이스 스키마를 실시간으로 감시하며, `posts` 같은 테이블이 생성되면 그 구조를 즉시 분석합니다. 분석이 끝나면, 코드 생성이나 서버 재시작 없이 해당 테이블을 조작할 수 있는 표준 RESTful API 엔드포인트(`GET /posts`, `POST /posts` 등)를 즉시, 그리고 동적으로 생성하여 열어줍니다. 결국 **데이터베이스 스키마 자체가 살아있는 API 명세**가 되는 셈입니다.

`supabase-js` 같은 라이브러리는 이렇게 자동으로 열린 API를 더 편리하게 호출하기 위한 '래퍼(wrapper)' 역할을 수행합니다. 예를 들어, 아래 코드는 라이브러리 내부에서 실제 HTTP 요청으로 변환되어 서버로 전송됩니다.

  * **`supabase-js` 코드:**
    ```javascript
    supabase.from('posts').select('*')
    ```
  * **실제 생성되는 HTTP 요청:**
    ```
    GET https://<YOUR_PROJECT_URL>.supabase.co/rest/v1/posts?select=*
    ```

##### 📝 예시: `posts` 테이블 API 사용하기

이제 프론트엔드 코드(예: React, Vue, Svelte)에서 `supabase-js` 라이브러리를 사용하여 방금 만든 `posts` 테이블을 어떻게 다루는지 보세요. 서버 코드는 한 줄도 없습니다\!

```javascript
// --- 데이터 조회 (SELECT) ---
async function getPosts() {
  const { data: posts, error } = await supabase
    .from('posts') // 'posts' 테이블에서
    .select('*'); // 모든 컬럼을 조회

  if (error) console.error('Error fetching posts:', error);
  else console.log('Fetched posts:', posts);
}

getPosts(); // 함수 호출 예시
```

이처럼 테이블 이름(`posts`)과 원하는 동작(`select`, `insert`, `update`, `delete`)을 메서드 체인 형태로 직관적으로 호출하기만 하면 됩니다. 이것이 Supabase가 개발자의 생산성을 극적으로 높여주는 이유입니다.

-----

#### 📡 실시간 구독 (Realtime Subscriptions) 상세 설명

실시간 구독은 데이터베이스에 **변경 사항이 생겼을 때, 서버가 클라이언트에게 즉시 알려주는(push) 기능**입니다. 클라이언트가 주기적으로 "새로운 데이터 있나요?"라고 물어볼 필요 없이, 변경이 발생한 순간 데이터를 받아볼 수 있습니다.

##### 어떻게 동작하나요?
Supabase는 PostgreSQL의 논리적 복제(Logical Replication) 기능을 활용합니다. `posts` 테이블에 `INSERT`가 발생하면, PostgreSQL은 이 변경사항을 특별한 채널로 발행(publish)합니다. Supabase의 실시간 서버는 이 채널을 듣고 있다가, 변경을 감지하면 웹소켓(WebSocket)을 통해 연결된 클라이언트에게 변경된 데이터를 즉시 전송해 줍니다.

##### 📝 예시: 새로운 게시글 실시간으로 받기
위에서 만든 `posts` 테이블에 새로운 글이 추가될 때마다 콘솔에 로그를 출력하는 실시간 기능을 구현해 보겠습니다.

**1. 테이블에 실시간 기능 활성화 (Supabase 대시보드)**
1.  Supabase 대시보드에서 `Database` \> `Replication` 메뉴로 이동합니다.
2.  Source `public` 아래에 있는 `posts` 테이블의 `INSERT`, `UPDATE`, `DELETE` 이벤트를 활성화(toggle)해 줍니다. 이렇게 해야 Supabase가 해당 테이블의 변경사항을 감지하기 시작합니다.

**2. 실시간 구독 코드 (JavaScript)**

클라이언트 코드에 아래와 같이 구독 로직을 추가합니다.

```javascript
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = 'YOUR_SUPABASE_URL';
const supabaseKey = 'YOUR_SUPABASE_ANON_KEY';
const supabase = createClient(supabaseUrl, supabaseKey);

// 'posts' 테이블의 모든 INSERT 이벤트를 구독합니다.
const postSubscription = supabase
  .channel('custom-insert-channel') // 채널 이름은 자유롭게 지정 가능
  .on(
    'postgres_changes', // 데이터베이스 변경을 감지
    {
      event: 'INSERT', // 어떤 이벤트? 'INSERT', 'UPDATE', 'DELETE', '*' (모두) 중 선택
      schema: 'public',
      table: 'posts',
    },
    (payload) => {
      // 변경이 감지되면 이 함수가 실행됩니다.
      console.log('새로운 게시글이 추가되었습니다!', payload);
      console.log('추가된 데이터:', payload.new);
      
      // 여기에 UI를 업데이트하는 코드를 작성할 수 있습니다.
      // 예: const newPost = payload.new;
      //      addPostToUI(newPost);
    }
  )
  .subscribe(); // 구독 시작!

console.log("새로운 게시글을 기다리는 중...");

// 구독을 중지하고 싶을 때
// setTimeout(() => {
//   supabase.removeChannel(postSubscription);
//   console.log("구독 중지!");
// }, 60000); // 1분 후 구독 중지 예시
```

이제 이 코드가 실행 중인 상태에서, 다른 사용자나 관리자가 `posts` 테이블에 새로운 글을 **추가**하면, 클라이언트의 콘솔에 `새로운 게시글이 추가되었습니다!`라는 메시지와 함께 추가된 데이터(`payload.new`)가 즉시 출력되는 것을 확인할 수 있습니다.

이 기능을 활용하면 **실시간 채팅**, **새 글/댓글 알림**, **라이브 대시보드**, **온라인 사용자 목록** 등 동적인 상호작용이 필요한 거의 모든 기능을 아주 간단하게 구현할 수 있습니다.


### Supabase 프로젝트 설정

#### 1. Supabase Console 설정

1. **Supabase** 가입: https://supabase.com/
2. **새 프로젝트 생성**
3. **Database 패스워드 설정**
4. **API Keys 확인**:
    - `anon` key: 클라이언트에서 사용
    - `service_role` key: 서버에서 사용
---

### 🐘 Supabase로 Todo API 마이그레이션

`todos.json` 파일을 버리고, 우리의 API가 Supabase 데이터베이스와 통신하도록 코드를 변경해 봅시다. 

#### 1. Supabase 프로젝트 설정
1. [Supabase 공식 홈페이지](https://supabase.com/)에 가입하고 새 프로젝트를 생성합니다.
2. 왼쪽 메뉴 **Authentication** > **Providers**에서 Email이 기본 활성화된 것을 확인합니다. 
3. 왼쪽 메뉴 SQL Editor에서 하기 문법 실행
```sql
-- public 스키마에 todos 테이블을 생성합니다.
CREATE TABLE public.todos (
  -- id: 8바이트 정수, 자동 증가하는 기본 키로 설정
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  -- created_at: 타임존 포함 시간, 기본값은 현재 시간
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,

  -- title: 텍스트 타입, 빈 텍스트는 허용하지 않음
  title TEXT CHECK (char_length(title) > 0) NOT NULL,

  -- completed: 불리언 타입, 기본값은 false
  completed BOOLEAN DEFAULT false NOT NULL,

  -- user_id: Supabase 인증 사용자의 id를 참조하는 외래 키
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL
);

-- 테이블에 대한 설명 추가
COMMENT ON TABLE public.todos IS 'Todo list items';
```
#### 2. Node.js 프로젝트에 Supabase 연동
```bash
# Supabase 클라이언트 라이브러리 설치
npm install @supabase/supabase-js
```

프로젝트의 `app.js` 파일 최상단에 Supabase 클라이언트 설정 코드를 추가합니다. 
(API URL과 anon key는 Supabase 프로젝트 상단 `Connect`  -> App Frameworks  에서 확인 가능)


```JavaScript
// app.js 상단

// 키값 별도 저장 .env 파일 사용
// npm install dotenv 추가 설치 
require('dotenv').config();

const { createClient } = require('@supabase/supabase-js');

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_ANON_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);
```


#### 3. 인증 및 미들웨어 로직 교체

supabase의 인증을 이용해서 sign up을 합니다.


> [!NOTE] SignUP 후 Email Confirm 필요
> Email 에서 실제 Confirm 이후 동작됨


```js
// 회원가입
app.post('/api/auth/signup', async (req, res) => {
    const { email, password } = req.body;
    const { data, error } = await supabase.auth.signUp({
        email: email,
        password: password,
    });

    if (error) return res.status(400).json({ error: error.message });
    res.status(201).json({ user: data.user });
});

// 로그인
app.post('/api/auth/login', async (req, res) => {
    const { email, password } = req.body;
    const { data, error } = await supabase.auth.signInWithPassword({
        email: email,
        password: password,
    });

    if (error) return res.status(400).json({ error: error.message });
    res.json({ accessToken: data.session.access_token });
});
```

미들웨어도 교체합니다
```js
// Supabase 토큰을 검증하고 사용자 정보를 req 객체에 추가하는 미들웨어
async function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
        return res.status(401).json({ error: '인증 토큰이 없습니다.' });
    }

    // Supabase에 토큰 검증 요청
    const { data: { user }, error } = await supabase.auth.getUser(token);

    if (error || !user) {
        return res.status(403).json({ error: '유효하지 않은 토큰입니다.' });
    }

    req.user = user; // 요청 객체에 user 정보 저장 (id, email 등 포함)
    next();
}
```

##### test.http 
```http

### 1. 회원가입 (Supabase Auth 사용)
POST http://localhost:3000/api/auth/signup
Content-Type: application/json

{
    "email": "test03@gmail.com",
    "password": "strong-password-123"
}

### 2. 로그인 및 토큰 발급
# @name login
POST http://localhost:3000/api/auth/login
Content-Type: application/json

{
    "email": "test03@gmail",
    "password": "strong-password-123"
}

### 3. 발급받은 토큰 변수에 저장
@authToken = {{login.response.body.accessToken}}

### 4. 인증 토큰을 사용하여 할 일 생성하기
# 이제부터 Authorization 헤더에 토큰을 담아 요청합니다.
POST http://localhost:3000/api/todos
Content-Type: application/json
Authorization: Bearer {{authToken}}

{
    "title": "인증된 사용자의 첫 할 일"
}

### 5. 인증 토큰을 사용하여 모든 할 일 조회
GET http://localhost:3000/api/todos
Authorization: Bearer {{authToken}}
```

#### 4. CRUD 로직을 Supabase 코드로 교체
기존에 `fs.readFileSync`, `fs.writeFileSync`를 사용하던 부분을 Supabase 클라이언트 코드로 바꿉니다. 코드가 얼마나 간단하고 명료해지는지 보세요.

##### CREATE - 새로운 할 일 추가
```js
// CREATE: 새로운 할 일 생성
app.post('/api/todos', authenticateToken, async (req, res) => {
    const { title } = req.body;
    const userId = req.user.id; // 미들웨어에서 넣어준 사용자 ID

    // Supabase에 데이터 삽입 요청
    const { data, error } = await supabase
        .from('todos')
        .insert([{ title: title, user_id: userId }])
        .select() // 삽입된 데이터를 바로 반환받음
        .single(); // 배열이 아닌 단일 객체로 받기 위함

    // 1. 에러 핸들링: Supabase가 error 객체를 반환했는지 확인
    if (error) {
        console.error('Supabase insert error:', error.message);
        // Supabase가 제공하는 에러 메시지를 클라이언트에 전달
        return res.status(400).json({ error: error.message });
    }

    // 2. 성공 시 처리: 에러가 없다면 data를 클라이언트에 반환
    res.status(201).json(data);
});
```

##### READ - 모든 할 일 조회
```js
// 기존 app.get('/api/todos', ...) 수정
app.get('/api/todos', authenticateToken, async (req, res) => {
    const userId = req.user.id;

    const { data, error } = await supabase
        .from('todos')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false }); // 최신순으로 정렬

    if (error) {
        return res.status(400).json({ error: error.message });
    }

    res.json(data);
});
```

##### READ - 특정  할 일 조회
```js
// READ: 특정 할 일 조회
app.get('/api/todos/:id', authenticateToken, async (req, res) => {
    const todoId = req.params.id;
    const userId = req.user.id;

    const { data, error } = await supabase
        .from('todos')
        .select('*')
        .eq('id', todoId)
        .eq('user_id', userId)
        .single();

    if (error) {
        return res.status(400).json({ error: error.message });
    }
    if (!data) {
        return res.status(404).json({ error: 'Todo not found or you do not have permission to view it.' });
    }

    res.json(data);
});
```
##### UPDATE - 할 일 수정
```js
// UPDATE: 특정 할 일 수정 (제목 또는 완료 상태)
app.put('/api/todos/:id', authenticateToken, async (req, res) => {
    const todoId = req.params.id;
    const userId = req.user.id;
    const { title, completed } = req.body;

    const { data, error } = await supabase
        .from('todos')
        .update({ title, completed })
        .eq('id', todoId)
        .eq('user_id', userId) // 본인의 할 일만 수정 가능하도록 강제
        .select()
        .single();

    if (error) {
        return res.status(400).json({ error: error.message });
    }
    if (!data) {
        return res.status(404).json({ error: '해당 할 일을 찾을 수 없거나 수정 권한이 없습니다.' });
    }

    res.json(data);
});
```

##### DELETE - 할 일 삭제
```js
// 기존 app.delete('/api/todos/:id', ...) 수정
// DELETE: 특정 할 일 삭제
app.delete('/api/todos/:id', authenticateToken, async (req, res) => {
    const todoId = req.params.id;
    const userId = req.user.id;

    const { error } = await supabase
        .from('todos')
        .delete()
        .eq('id', todoId)
        .eq('user_id', userId); // 본인의 할 일만 삭제 가능하도록 강제

    if (error) {
        return res.status(400).json({ error: error.message });
    }

    res.status(204).send(); // 성공적으로 삭제되었으나 별도의 본문은 없음을 의미
});
```

파일을 읽고, JSON으로 파싱하고, 배열을 조작하고, 다시 파일에 쓰는 복잡한 과정이 `supabase.from('테이블명').동작()` 형태의 직관적인 코드로 모두 대체되었습니다. 이것이 바로 BaaS의 강력함입니다.
